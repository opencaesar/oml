/*
 * This Ecore package specifies the syntax (metamodel) of the Ontological Modeling Language. OML models are instances of 
 * this metamodel and can be manipulated using its API.     
 */
@Ecore(
    nsPrefix="oml",
    nsURI="http://opencaesar.io/oml"
)
@GenModel(
    copyrightText="\nCopyright 2019-2022 California Institute of Technology (\"Caltech\").\nU.S. Government sponsorship acknowledged.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n",
    modelDirectory="/io.opencaesar.oml/src-gen",
    editDirectory="/io.opencaesar.oml.edit/src-gen",
    //editorDirectory="/io.opencaesar.oml.editor/src-gen",
    importerID="org.eclipse.xsd.ecore.importer",
    complianceLevel="11.0"
)
@BikeshedHeadings(
    Elements="",
    Literals="",
    Vocabularies="",
    Types="",
    Properties="",
    Rules="",
    Axioms="",
    Descriptions="",
    Instances="",
    Assertions="",
    Enumerations=""
)
@Bikeshed(heading="Abstract-Syntax")
package io.opencaesar.oml

import io.opencaesar.oml.util.OmlValidator2
import java.math.BigDecimal
import org.eclipse.emf.ecore.EDiagnosticChain
import org.eclipse.emf.ecore.EMap
import org.eclipse.emf.ecore.EObject

annotation "https://tabatkins.github.io/bikeshed" as Bikeshed
annotation "https://tabatkins.github.io/bikeshed/headings" as BikeshedHeadings

////////////////////////////////////////
//  Root 
////////////////////////////////////////

/*
 * Element is the most general type in the OML metamodel. All objects in an OML model are elements.
 */
@Bikeshed(heading="Elements")
abstract class Element {
    /*
     * Validates this element by extra validation rules
     * @param diagnostics validation error diagnostics
     * @param context object-to-object map used in producing messages 
     */
    op boolean extraValidate(EDiagnosticChain diagnostics, EMap<Object, Object>context) {
        return OmlValidator2.INSTANCE.run(this, diagnostics, context)
    }
    /*
     * Gets the ontology that defines this element
     */
    op Ontology getOntology() {
        var EObject current = this;
        while (current !== null && !(current instanceof Ontology)) {
            current = current.eContainer()
        }
        return current as Ontology
    }
}

////////////////////////////////////////
//  Elements 
////////////////////////////////////////

/*
 * Annotation is an element that specifies additional non-semantic statements on an annotated element. 
 * An annotation is specified with an annotation property and a (literal or reference) value. When
 * no value is specified, it is interpreted as the `true` boolean literal.
 */
@Bikeshed(heading="Elements")
class Annotation extends Element {
    /*
     * The annotation property specified by this annotation
     */
    refers AnnotationProperty[1] property
    /*
     * A literal value specified by this annotation.
     */
    contains Literal[?] literalValue
    /*
     * A reference (to a member) value specified by this annotation
     */
    refers Member[?] referenceValue
    /*
     * The annotated element that owns this annotation
     */
    container IdentifiedElement[?] owningElement opposite ownedAnnotations
    /*
     * Gets the value of the annotation
     */
    op Element getValue() {
    	if (literalValue !== null)
    		literalValue
    	else if (referenceValue !== null)
    		referenceValue
    }
}

/*
 * IdentifiedElement is an annotated element that is identified by an IRI and can own a set of Annotations.
 */
@Bikeshed(heading="Elements")
abstract class IdentifiedElement extends Element {
    /*
     * The set of annotations owned directly by this element
     */
    contains Annotation[*] ownedAnnotations opposite owningElement
    /*
     * Gets the IRI of this element 
     */ 
    op String getIri()
}

/*
 * Import is an element owned by an ontology to specify that it imports another ontology.
 * The imported ontology is specified by its IRI, and optionally a separator character and local prefix
 * if members of the imported ontology will also be referenced by the importing ontology
 */
@Bikeshed(heading="Elements")
class Import extends Element {
	/*
	 * The kind of this import
	 */
	ImportKind[1] kind
    /*
     * The namespace of the imported ontology
     */
    Namespace[1] namespace
    /*
     * The local prefix of the imported ontology's namespace
     */
    ID[?] prefix
    /*
     * The ontology that owns this import
     */
    container Ontology[1] owningOntology opposite ownedImports
    /*
     * Get the import's iri
     */
    op String getIri() {
    	if (namespace === null) {
    		return null
    	}
     	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
        	return namespace
       	} else {
       		return namespace.substring(0, i)
       	}
    }
    /*
     * Get the import's separator char
     */
    op SeparatorKind getSeparator() {
     	if (namespace === null) {
    		return null
    	}
    	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
       		return null
       	} else {
        	return SeparatorKind.get(namespace.substring(i, i+1))
       	}
    }
}

/*
 * Instance is an element that represents an instance of a classifier. It can specify a set of values for the
 * classifier's (direct or inherited) properties.
 */
@Bikeshed(heading="Instances")
abstract class Instance extends Element {
    /*
     * The property value assertions specified by this instance
     */
    contains PropertyValueAssertion[*] ownedPropertyValues opposite owningInstance
}

/*
 * Axiom is an annotated element that represents a statement about a term in a vocabulary.
 */
@Bikeshed(heading="Axioms")
abstract class Axiom extends Element {
}

/*
 * Assertion is an element that represents a statement about an instance in a description.
 */
@Bikeshed(heading="Assertions")
abstract class Assertion extends Element {
}

/*
 * Predicate is an element that represents an ontology statement to match, when used in a rule's antecedent, 
 * or to infer, when used in a rule's consequent.
 */
@Bikeshed(heading="Rules")
abstract class Predicate extends Element {
    /*
     * The rule that specifies this predicate in its antecedent
     */
    container Rule[?] antecedentRule opposite antecedent
    /*
     * The rule that specifies this predicate in its consequent
     */
    container Rule[?] consequentRule opposite consequent
}

/*
 * Argument is an element that represents an argument to a predicate specified as a variable, a literal, or an instance
 */
@Bikeshed(heading="Rules")
class Argument extends Element {
    /*
     * An optional variable specified by this argument
     */
    ID[?] variable
    /*
     * An optional literal specified by this argument
     */
    contains Literal[?] literal
    /*
     * An optional instance specified by this argument
     */
    refers NamedInstance[?] instance
}

/*
 * Literal is an element that represents a specific literal value classified by a scalar.
 */
@Bikeshed(heading="Literals")
abstract class Literal extends Element {
}

////////////////////////////////////////
//  Identified Elements 
////////////////////////////////////////

/*
 * Ontology is an identified element that represents a namespace for its members. The namespace is defined
 * by a globally unique namespace (an iri and a namespace separator that can be # or /) and can be abbreviated with a prefix. 
 * An ontology can import other ontologies, and can make statements about its own as well as imported members.
 */
@Bikeshed(heading="Elements")
abstract class Ontology extends IdentifiedElement {
    /*
     * The globally unique namespace of this ontology
     */
    Namespace[1] namespace
    /*
     * The prefix of this ontology's namespace
     */
    ID[1] prefix
    /*
     * The set of imports this ontology has to other ontologies
     */
    contains Import[*] ownedImports opposite owningOntology
    /*
     * Get the namespace's iri
     */
    op String getIri() {
    	if (namespace === null) {
    		return null
    	}
     	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
        	return namespace
       	} else {
       		return namespace.substring(0, i)
       	}
    }
    /*
     * Get the namespace's separator char
     */
    op SeparatorKind getSeparator() {
     	if (namespace === null) {
    		return null
    	}
    	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
       		return null
       	} else {
        	return SeparatorKind.get(namespace.substring(i, i+1))
       	}
    }
}

/*
 * Member is an identified element defined by an ontology. Its IRI is unique and derived by concatenating the globally
 * unique namespace of its ontology with its locally unique name (i.e., member.iri=ontology.namespace+member.name).
 */
@Bikeshed(heading="Elements")
abstract class Member extends IdentifiedElement {
    /*
     * A unique name for the member within its ontology
     */
    id ID[?] name
    
    /*
     * Gets the Ref of this member
     */
    op Member[?] getRef()
    /*
     * Determines if the member is a ref to another member
     */
    op boolean isRef() {
    	return getRef() !== null
    }
    /*
     * Gets the IRI of this member
     */
    op String getIri() {
    	val m = if (getRef() !== null) getRef() else this
        val ontology = m.getOntology()
        val namespace = if (ontology !== null) ontology.getNamespace() else SeparatorKind.HASH
        return namespace+m.getName()
    }
    /*
     * Gets the abbreviated IRI of this member
     */
    op String getAbbreviatedIri() {
     	val m = if (getRef() !== null) getRef() else this
        val ontology = m.getOntology();
        val prefix = if (ontology !== null) ontology.getPrefix()+':' else ':'
        return prefix + m.getName()
    }
}

////////////////////////////////////////
//  Ontologies 
////////////////////////////////////////

/*
 * VocabularyBox is an ontology whose members are terms and rules.
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyBox extends Ontology {
}

/*
 * DescriptionBox is an ontology whose members are instances (of terms defined in vocabulary boxes)
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionBox extends Ontology {
}

////////////////////////////////////////
//  Vocabulary Boxes 
////////////////////////////////////////

/*
 * Vocabulary is a vocabulary box that allows making statements about its own terms and rules
 * or about others that are imported.
 */
@Bikeshed(heading="Vocabularies")
class Vocabulary extends VocabularyBox {
    /*
     * The set of statements contained by this vocabulary
     */
    contains VocabularyStatement[*] ownedStatements opposite owningVocabulary
}

/*
 * VocabularyBundle is a vocabulary box that allows importing other vocabulary boxes and flagging them
 * as disjoint from one another.
 */
@Bikeshed(heading="Vocabularies")
class VocabularyBundle extends VocabularyBox {
}

////////////////////////////////////////
//  Description Boxes 
////////////////////////////////////////

/*
 * Description is a description box that allows making statements about its own instances or about
 * others that are imported.
 */
@Bikeshed(heading="Descriptions")
class Description extends DescriptionBox {
    /*
     * The set of statements contained by this description
     */
    contains DescriptionStatement[*] ownedStatements opposite owningDescription
}

/*
 * DescriptionBundle is a description box that allows importing other description boxes and flagging them
 * as a set that is analyzed together for consistency and satisfiabilty.
 */
@Bikeshed(heading="Descriptions")
class DescriptionBundle extends DescriptionBox {
}

////////////////////////////////////////
//  Members 
////////////////////////////////////////

/*
 * Statement is a member that is owned by an ontology.  
 */
@Bikeshed(heading="Elements")
abstract class Statement extends Member {
}

/*
 * VocabularyMember is a member of a vocabulary.
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyMember extends Member {
}

/*
 * DescriptionMember is a member of a description.
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionMember extends Member {
}

////////////////////////////////////////
//  Statements 
////////////////////////////////////////

/*
 * VocabularyStatement is a statement owned by a vocabulary.
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyStatement extends Statement, VocabularyMember {
    /*
     * The vocabulary that owns this statement
     */
    container Vocabulary[1] owningVocabulary opposite ownedStatements
}

/*
 * DescriptionStatement is a statement owned by a description.
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionStatement extends Statement, DescriptionMember {
    /*
     * The description that owns this statement
     */
    container Description[1] owningDescription opposite ownedStatements
}

////////////////////////////////////////
//  Vocabulary Members
////////////////////////////////////////

/*
 * Term is a member of a vocabulary that provides a particular semantic meaning when used in an assertion.
 */
@Bikeshed(heading="Vocabularies")
abstract class Term extends VocabularyMember {
}

/*
 * Rule is a member of a vocabulary that adds a new inference rule to the set supported natively by DL. A rule must specify a set of one or
 * more antecedent predicates that forms a conjunction that infers, when it holds, a set of one or more consequent predicates. Each
 * predicate in a rule may specify (one or two) variables. Those with the same name refer to the same variable, and hence must
 * be bound to the same value from the model for the rule to trigger during reasoning. A rule ref cannot respecify the
 * antecedent nor consequent of a rule.
 */
@Bikeshed(heading="Rules")
class Rule extends VocabularyStatement {
	/*
	 * A ref to another rule
	 */
	refers Rule ref
    /*
     * The set of predicates that form the antecedent of this rule
     */
    contains Predicate[*] antecedent opposite antecedentRule
    /*
     * The predicate that is the consequent of this rule
     */
    contains Predicate[*] consequent opposite consequentRule
}

/*
 * BuiltIn is a member of a vocabulary that represents a builtin function
 */
@Bikeshed(heading="Rules")
class BuiltIn extends VocabularyStatement {
	/*
	 * A ref to another builtin
	 */
	refers BuiltIn ref
}

////////////////////////////////////////
//  Terms 
////////////////////////////////////////

/*
 * SpecializableTerm is a term that can specialized in a taxonomy. It can have zero or more specializations.
 */
@Bikeshed(heading="Vocabularies")
abstract class SpecializableTerm extends Term, VocabularyStatement {
    /*
     * The specialization axioms owned by this term
     */
    contains SpecializationAxiom[*] ownedSpecializations opposite owningTerm
}

/*
 * Property is a term that relates an element to a value. It is the super type of all property types.
 */
@Bikeshed(heading="Properties")
abstract class Property extends Term {
}

////////////////////////////////////////
//  Specializable Terms
////////////////////////////////////////

/*
 * Type is a specializable term that classifies a set of instances or literals.
 */
@Bikeshed(heading="Types")
abstract class Type extends SpecializableTerm {
}

/*
 * RelationBase is a specializable term that is the superclass of a relation from a source entity to a target entity.
 * It can optionally name a reverse property whose domain is the target and whose range is the source.
 * It can also be characterized with several boolean flags that represent its DL semantics. 
 * Such flags apply conversely to the reverse property (if named). A relation base ref cannot respecify the source,
 * the target, nor the reverse relation. 
 */
@Bikeshed(heading="Properties")
abstract class RelationBase extends SpecializableTerm {
    /*
     * The entity that represents the source of this relation base
     */
    refers Entity[?] source
    /*
     * The entity that represents the target of this relation base
     */
    refers Entity[?] target
    /*
     * The optional reverse relation of this relation base
     */
    contains ReverseRelation[?] reverseRelation opposite relationBase
    /*
     * Whether this relation base is functional (i.e., {@code A -> B and A->C => B=C})
     */
    boolean functional
    /*
     * Whether this relation base is inverse functional (i.e., {@code B->A and C->A => B=C})
     */
    boolean inverseFunctional
    /*
     * Whether this relation base is symmetric (i.e., {@code A->B => B->A})
     */
    boolean symmetric
    /*
     * Whether this relation base is asymmetric (i.e., {@code A->B => !(B->A)})
     */
    boolean asymmetric
    /*
     * Whether this relation base is reflexive (i.e., {@code A => A->A})
     */
    boolean reflexive
    /*
     * Whether this relation base is irreflexive (i.e., {@code A => !(A->A)})
     */
    boolean irreflexive
    /*
     * Whether this relation base is transitive (i.e., {@code A->B and B->C => A->C})
     */
    boolean transitive
}

////////////////////////////////////////
//  Types
////////////////////////////////////////

/*
 * Classifier is a type that classifies a set of instances and characterizes them with properties
 * (i.e., becomes a domain of these properties). It also inherits properties in the domain of its specialized 
 * types. In addition, it can specify constraints on (direct or inherited) properties in its domain.
 */
@Bikeshed(heading="Types")
abstract class Classifier extends Type {
    /*
     * The set of property restriction axioms of this classifier
     */
    contains PropertyRestrictionAxiom[*] ownedPropertyRestrictions opposite owningClassifier
}

/*
 * Scalar is a primitive type that represents a set of literals. It is the super type of all scalar types.
 */
@Bikeshed(heading="Types")
abstract class Scalar extends Type {
}

////////////////////////////////////////
//  Classifiers
////////////////////////////////////////

/*
 * Entity is a classifier whose instances are named and can be interrelated. It can also additionally specify key axioms
 * that define how instances of the entity are unique.
 */
@Bikeshed(heading="Types")
abstract class Entity extends Classifier {
    /*
     * The unique keys of this entity
     */
    contains KeyAxiom[*] ownedKeys opposite owningEntity
}

/*
 * Structure is a characterizable type that represents a structured datatype whose instances are anonymous and assignable as
 * values to structured properties.
 */
@Bikeshed(heading="Types")
class Structure extends Classifier {
	/*
	 * A ref to another structure
	 */
	refers Structure ref
}

////////////////////////////////////////
//  Entities
////////////////////////////////////////

/*
 * Aspect is an entity that represents a concern that cuts across multiple entities. It does not directly 
 * classify instances, but it does so indirectly by being specialized by other entities. However, an aspect can only 
 * specialize other aspects.
 */
@Bikeshed(heading="Types")
class Aspect extends Entity {
	/*
	 * A ref to another aspect
	 */
	refers Aspect ref
}

/*
 * Concept is a concrete entity that classifies a (possibly enumerated) set of concept instances. 
 * It can also specialize other concepts and/or aspects. A concept ref cannot respecify the enumerated instances.
 */
@Bikeshed(heading="Types")
class Concept extends Entity {
	/*
	 * A ref to another concept
	 */
	refers Concept ref
	/*
	 * The set of enumerated instances of this concept
	 */
	refers ConceptInstance[*] enumeratedInstances
}

/*
 * RelationEntity is an entity that represents a reified relation from a source entity to a target entity. 
 * It can optionally name a forward property whose domain is the source and whose range is the target.
 * If both are named, such forward property becomes the inverse of the entity's reverse property. 
 * If not, then a default forward property with the name 'has<Relation>Forward' is assumed. A relation entity ref
 * cannot respecify a forward relation.
 */
@Bikeshed(heading="Types")
class RelationEntity extends Entity, RelationBase {
	/*
	 * A ref to another relation entity
	 */
	refers RelationEntity ref
    /*
     * The optional forward relation of this relation entity
     */
    contains ForwardRelation[?] forwardRelation opposite relationEntity
}

////////////////////////////////////////
//  Scalars
////////////////////////////////////////

/*
 * FacetedScalar is a scalar that represents a (possibly infinite) set of literals and can constrain them with some facets. It
 * can also specialize other faceted scalars. OML considers some faceted scalars, those defined by the OWL2 specification 
 * (https://www.w3.org/TR/owl2-syntax/#Datatype_Maps) and listed below, as standard. Other non-standard scalars can specialize directly 
 * or transitively from this standard set and optionally specify facets (restrictions on their lexical or value spaces). 
 * A scalar that specifies facets can only have a single supertype, which must be a standard one. Otherwise, it must have at least one
 * supertype that is considered to be an alias.
 * 
 * Numeric scalars (facets: minInclusive, maxInclusive, minExclusive, maxExclusive):
 * owl:real
 * owl:rational
 * xsd:decimal
 * xsd:integer
 * xsd:nonNegativeInteger
 * xsd:nonPositiveInteger
 * xsd:positiveInteger
 * xsd:negativeInteger
 * xsd:long
 * xsd:int
 * xsd:short
 * xsd:byte
 * xsd:unsignedLong
 * xsd:unsignedInt
 * xsd:unsignedShort
 * xsd:unsignedByte
 * xsd:double
 * xsd:float 
 * 
 * Time scalars (facets: minInclusive, maxInclusive, minExclusive, maxExclusive):
 * xsd:dateTime
 * xsd:dateTimeStamp
 * 
 * Plain scalars (facets: length, minLength, maxLength, pattern, language):
 * rdf:PlainLiteral

 * String scalars (facets: length, minLength, maxLength, pattern)
 * xsd:string,
 * xsd:normalizedString,
 * xsd:token,
 * xsd:language,
 * xsd:Name,
 * xsd:NCName,
 * xsd:NMTOKEN
 * xsd:anyURI
 * 
 * Boolean scalars (no facets):
 * xsd:boolean
 * 
 * Binary scalars (facets: length, minLength, maxLength):
 * xsd:hexBinary
 * xsd:base64Binary
 * 
 * XML scalars (no facets):
 * rdf:XMLLiteral
 */
@Bikeshed(heading="Types")
class FacetedScalar extends Scalar {
	/*
	 * A ref to another faceted scalar
	 */
	refers FacetedScalar ref
    /*
     * The exact length of the literals of this scalar
     */
    UnsignedInteger[?] length
    /*
     * The minimum length of the literals of this scalar
     */
    UnsignedInteger[?] minLength
    /*
     * The maximum length of the literals of this scalar
     */
    UnsignedInteger[?] maxLength
    /*
     * The pattern that the literals of this scalar conforms to
     */
    String[?] pattern
    /*
     * The language range that the literals of this scalar belong to 
     * (based on http://www.rfc-editor.org/rfc/bcp/bcp47.txt)
     */
    String[?] language
    /*
     * The minimum inclusive value of numeric literals of this scalar
     */
    contains Literal[?] minInclusive
    /*
     * The minimum exclusive value of numeric literals of this scalar
     */
    contains Literal[?] minExclusive
    /*
     * The maximum inclusive value of numeric literals of this scalar
     */
    contains Literal[?] maxInclusive
    /*
     * The maximum exclusive value of numeric literals of this scalar
     */
    contains Literal[?] maxExclusive
}

/*
 * EnumeratedScalar is a scalar that represents a finite set of literals. It can specialize another enumerated scalar, but in
 * this case, it cannot define its own literals; rather, it will simply be considered an alias to the specialized scalar.
 * An enumerated scalar ref cannot respecify the literals.
 */
@Bikeshed(heading="Types")
class EnumeratedScalar extends Scalar {
	/*
	 * A ref to another enumerated scalar
	 */
	refers EnumeratedScalar ref
    /*
     * The set of enumerated literals that are represented by this scalar
     */
    contains Literal[*] literals
}

////////////////////////////////////////
//  Properties
////////////////////////////////////////

/*
 * AnnotationProperty is a property with no DL semantics that relates an annotated element to a literal value.
 */
@Bikeshed(heading="Properties")
class AnnotationProperty extends Property, SpecializableTerm {
	/*
	 * A ref to another annotation property
	 */
	refers AnnotationProperty ref
}

/*
 * SemanticProperty is a property with DL semantics that relates a classifier acting as its
 * domain to a type acting as its range.
 */
@Bikeshed(heading="Properties")
abstract class SemanticProperty extends Property {
    /*
     * Determines if this property is functional (has a max of one value per instance) 
     */
    op boolean isFunctional()
    /*
     * Gets the domain of this property
     */
    op Classifier getDomain()
    /*
     * Gets the range of the property
     */
    op Type getRange()
}

////////////////////////////////////////
//  Semantic Properties
////////////////////////////////////////

/*
 * ScalarProperty is a semantic property whose range is a scalar. It can specialize other scalar properties.
 * It can also be flagged as a key property (among possibly several) that specifies the unique id of its domain.
 * A scalar property ref cannot respecify the domain nor the range.
 */
@Bikeshed(heading="Properties")
class ScalarProperty extends SemanticProperty, SpecializableTerm {
	/*
	 * A ref to another scalar property
	 */
	refers ScalarProperty ref
    /*
     * Whether this property is functional (has a max of one value per instance) 
     */
    boolean functional
    /*
     * The classifier that is the domain of this property
     */
    refers Classifier[?] domain
    /*
     * The scalar that is the range of this property
     */
    refers Scalar[?] range
}

/*
 * StructuredProperty is a semantic property whose range is a structure. It can specialize other structured properties.
 * A structured property ref cannot respecify the domain nor the range.
 */
@Bikeshed(heading="Properties")
class StructuredProperty extends SemanticProperty, SpecializableTerm {
	/*
	 * A ref to another structured property
	 */
	refers StructuredProperty ref
    /*
     * Whether this property is functional (has a max of one value per instance) 
     */
    boolean functional
    /*
     * The classifier that is the domain of this property
     */
    refers Classifier[?] domain
    /*
     * The structure that is the range of this property
     */
    refers Structure[?] range
}

/*
 * Relation is a semantic property whose domain is an entity and whose range is also an entity.
 * It can be characterized by DL flags and can have an inverse relation.
 */
@Bikeshed(heading="Properties")
abstract class Relation extends SemanticProperty {
    /*
     * Gets whether this relation is inverse functional (i.e., {@code B->A and C->A => B=C})
     */
    op boolean isInverseFunctional()
    /*
     * Gets whether this relation is symmetric (i.e., {@code A->B => B->A})
     */
    op boolean isSymmetric()
    /*
     * Gets whether this relation is asymmetric (i.e., {@code A->B => !(B->A)})
     */
    op boolean isAsymmetric()
    /*
     * Gets whether this relation is reflexive (i.e., {@code A => A->A})
     */
    op boolean isReflexive()
    /*
     * Gets whether this relation is irreflexive (i.e., {@code A => !(A->A)})
     */
    op boolean isIrreflexive()
    /*
     * Gets whether this relation is transitive (i.e., {@code A->B and B->C => A->C})
     */
    op boolean isTransitive()
    /*
     * Gets the domain of this relation
     */
    op Entity getDomain()
    /*
     * Gets the range of the relation
     */
    op Entity getRange()
    /*
     * Gets the inverse of this relation
     */
    op Relation[?] getInverse()
}

////////////////////////////////////////
//  Relations
////////////////////////////////////////

/*
 * ForwardRelation is a relation that is defined by a relation entity. Its domain is the source of the relation
 * entity, and its range is the target of the relation entity. The DL semantics of a forward property are the same as those 
 * of its relation entity.
 */
@Bikeshed(heading="Properties")
class ForwardRelation extends Relation {
    /*
     * The relation entity that owns this forward property
     */
    container RelationEntity[1] relationEntity opposite forwardRelation
    
    op Member getRef() {
    	null
    }
    op boolean isFunctional() {
        relationEntity.functional
	}
    op boolean isInverseFunctional() {
        relationEntity.inverseFunctional
    }
    op boolean isSymmetric() {
        relationEntity.symmetric
    }
    op boolean isAsymmetric() {
        relationEntity.asymmetric
    }
    op boolean isReflexive() {
        relationEntity.reflexive
    }
    op boolean isIrreflexive() {
        relationEntity.irreflexive
    }
    op boolean isTransitive() {
        relationEntity.transitive
    }
    op Entity getDomain() {
		relationEntity.source
    }
    op Entity getRange() {
		relationEntity.target
    }
    op Relation getInverse() {
		relationEntity.reverseRelation
    }
}

/*
 * ReverseRelation is a relation that is defined by a relation base and represents its inverse relation. Its domain
 * is the target of the relation base, and its range is the source of the relation base. The DL semantics of a reverse property are 
 * derived from those of its relation.
 */
@Bikeshed(heading="Properties")
class ReverseRelation extends Relation {
    /*
     * The relation that owns this reverse property
     */
    container RelationBase[1] relationBase opposite reverseRelation
    
    op Member getRef() {
    	null
    }
    op boolean isFunctional() {
        relationBase.inverseFunctional
	}
    op boolean isInverseFunctional() {
        relationBase.inverseFunctional
    }
    op boolean isSymmetric() {
        relationBase.symmetric
    }
    op boolean isAsymmetric() {
        relationBase.asymmetric
    }
    op boolean isReflexive() {
        relationBase.reflexive
    }
    op boolean isIrreflexive() {
       relationBase.irreflexive
    }
    op boolean isTransitive() {
        relationBase.transitive
    }
    op Entity getDomain() {
        relationBase.target
    }
    op Entity getRange() {
        relationBase.source
    }
    op Relation getInverse() {
        if (relationBase instanceof RelationEntity)
            (relationBase as RelationEntity).forwardRelation
        else if (relationBase instanceof Relation)
        	relationBase as Relation
    }
}

/*
 * UnreifiedRelation is a simple relation from a source entity to a target entity. 
 */
@Bikeshed(heading="Properties")
class UnreifiedRelation extends Relation, RelationBase {
	/*
	 * A ref to another relation
	 */
	refers Relation ref

    op Entity getDomain() {
        source
    }
    op Entity getRange() {
    	target
    }
    op Relation getInverse() {
		reverseRelation
    }
}

////////////////////////////////////////
//  Description Members
////////////////////////////////////////

/*
 * NamedInstance is an instance that is a member of a description.
 */
@Bikeshed(heading="Instances")
abstract class NamedInstance extends DescriptionStatement, Instance {
    /*
     * The types of this instance
     */
    contains TypeAssertion[*] ownedTypes opposite owningInstance
}

////////////////////////////////////////
//  Named Instances
////////////////////////////////////////

/*
 * ConceptInstance is a named instance that can be typed by concepts.
 */
@Bikeshed(heading="Instances")
class ConceptInstance extends NamedInstance {
	/*
	 * A ref to another concept instance
	 */
	refers ConceptInstance ref
}

/*
 * RelationInstance is a named instance that can be typed by relation entities and represents a relation from one or 
 * more named instances (as sources) to one or more named instances (as targets).
 */
@Bikeshed(heading="Instances")
class RelationInstance extends NamedInstance {
	/*
	 * A ref to another relation instance
	 */
	refers RelationInstance ref
    /*
     * The named instances that are the sources of this relation instance
     */
    refers NamedInstance[*] sources
    /*
     * The named instances that are the targets of this relation instance
     */
    refers NamedInstance[*] targets
}

////////////////////////////////////////
//  Instances
////////////////////////////////////////

/*
 * StructureInstance is an instance that can be typed by a structure. It is anonymous and gets assigned as a value of a structured property
 * either in a property value restriction axiom or a property value assertion
 */
@Bikeshed(heading="Instances")
class StructureInstance extends Instance {
    /*
     * The type of this instance
     */
    refers Structure[1] ^type
    /*
     * The property value restriction axiom that assigns this instance as a restricted value
     */
    container PropertyValueRestrictionAxiom[?] owningAxiom opposite structureInstanceValue
    /*
     * The property value assertion that assigns this instance as a value
     */
    container PropertyValueAssertion[?] owningAssertion opposite structureInstanceValue
}

////////////////////////////////////////
//  Axioms
////////////////////////////////////////

/*
 * KeyAxiom is an axiom that specifies that a set of properties form a unique key for an entity. This means that all 
 * instances of that entity must have unique values for those keys.
 */
@Bikeshed(heading="Axioms")
class KeyAxiom extends Axiom {
    /*
     * The set of properties specified by this axiom as a key
     */
    refers Property[+] properties
    /*
     * The entity that owns this axiom
     */
    container Entity[?] owningEntity opposite ownedKeys
}

/*
 * SpecializationAxiom is an axiom specified on a specializing term that states that one specializable term specializes another.
 */
@Bikeshed(heading="Axioms")
class SpecializationAxiom extends Axiom {
    /*
     * The specialized term specified by this axiom 
     */
    refers SpecializableTerm[1] specializedTerm
    /*
     * The specializing term specified by this axiom 
     */
    container SpecializableTerm[?] owningTerm opposite ownedSpecializations
}

/*
 * PropertyRestrictionAxiom is an axiom specified on the classifier that places some restriction on the value of a semantic property in the context of
 * a restricting classifier domain.
 */
@Bikeshed(heading="Axioms")
abstract class PropertyRestrictionAxiom extends Axiom {
    /*
     * The restricting classifier specified by this axiom
     */
    container Classifier[?] owningClassifier opposite ownedPropertyRestrictions
    /*
     * The restricted property
     */
    refers SemanticProperty[1] property
}

////////////////////////////////////////
//  Property Restriction Axioms
////////////////////////////////////////

/*
 * PropertyRangeRestrictionAxiom is a property restriction axiom that restricts the range of a property to
 * a type that specializes the original range. This restrictions may apply to all or to some values of the property
 * that have the restricting classifier as a domain.
 */
@Bikeshed(heading="Axioms")
class PropertyRangeRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * The range restriction kind specified by this axiom (default is all)
     */
    RangeRestrictionKind[1] kind = "all" 
    /*
     * The restricted range specified by this axiom
     */
    refers Type[1] range
}

/*
 * PropertyCardinalityRestrictionAxiom is a property restriction axiom that restricts the cardinality of a property
 * to an exact value, a minimum value or a maximum value. This restrictions can apply either to all values of the property 
 * in the restricting classifier, or only to those values classified by a specific subtype of the range.
 */
@Bikeshed(heading="Axioms")
class PropertyCardinalityRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * The kind of cardinality restriction specified by this axiom (default is exactly)
     */
    CardinalityRestrictionKind[1] kind = "exactly"
    /*
     * The value of the cardinality specified by this axiom (default is 1)
     */
    UnsignedInt[1] cardinality = "1"
    /*
     * The optional restricted range specified by this axiom
     */
    refers Type[?] range
}

/*
 * PropertyValueRestrictionAxiom is a property restriction axiom that restricts a property in a given domain to a specific
 * value. The value is either a literal value in the case of a scalar property, a contained (structure) instance value in the case of
 * a structured property, or a referenced (named) instance value in the case of a relation.
 */
@Bikeshed(heading="Axioms")
class PropertyValueRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * A restricted literal value (of a scalar property) 
     */
    contains Literal[?] literalValue
    /*
     * A restricted structure instance value (of a structured property) 
     */
    contains StructureInstance[?] structureInstanceValue opposite owningAxiom
    /*
     * A restricted named instance value (of a relation) 
     */
    refers NamedInstance[?] namedInstanceValue
    /*
     * Gets the restricted value
     */
    op Element getValue() {
    	if (property instanceof ScalarProperty)
    		literalValue
    	else if (property instanceof StructuredProperty)
    		structureInstanceValue
    	else if (property instanceof Relation)
    		namedInstanceValue
    }
}

////////////////////////////////////////
//  Assertions
////////////////////////////////////////

/*
 * TypeAssertion is an assertion that specifies a type for an instance 
 */
@Bikeshed(heading="Assertions")
class TypeAssertion extends Assertion {
    /*
     * The type of the instance owning this assertion
     */
    refers Entity[1] ^type
    /*
     * The instance that owns this assertion
     */
    container NamedInstance[?] owningInstance opposite ownedTypes
}

/*
 * PropertyValueAssertion is an assertion that specifies a value for a property on an instance. The value is either a literal value 
 * in the case of a scalar property, a contained (structure) instance value in the case of a structured property, or a referenced 
 * (named) instance value in the case of a relation.
 */
@Bikeshed(heading="Assertions")
class PropertyValueAssertion extends Assertion {
    /*
     * The instance that this property value assertion is about
     */
    container Instance[?] owningInstance opposite ownedPropertyValues
    /*
     * The property referenced by this assertion
     */
    refers SemanticProperty[1] property
    /*
     * An asserted literal value of a scalar property 
     */
    contains Literal[?] literalValue
    /*
     * An asserted structure instance value of a structured property 
     */
    contains StructureInstance[?] structureInstanceValue opposite owningAssertion
    /*
     * An asserted named instance value of a relation 
     */
    refers NamedInstance[?] namedInstanceValue
    /*
     * Gets the asserted value
     */
    op Element getValue() {
    	if (property instanceof ScalarProperty)
    		literalValue
    	else if (property instanceof StructuredProperty)
    		structureInstanceValue
    	else if (property instanceof Relation)
    		namedInstanceValue
    }
}

////////////////////////////////////////
//  Predicates
////////////////////////////////////////

/*
 * UnaryPredicate is a predicate that has one argument
 */
@Bikeshed(heading="Rules")
abstract class UnaryPredicate extends Predicate {
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument
}

/*
 * BinaryPredicate is a predicate that has two arguments: argument1 and argument2
 */
@Bikeshed(heading="Rules")
abstract class BinaryPredicate extends Predicate {
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument1
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument2
}

/*
 * BuiltInPredicate is a predicate that has two arguments: argument1 and argument2
 */
@Bikeshed(heading="Rules")
class BuiltInPredicate extends Predicate {
    /*
     * The called builtin
     */
    refers BuiltIn[1] builtIn
    /*
     * An argument of the predicate
     */
    contains Argument[+] arguments
}

////////////////////////////////////////
//  Unary Predicates
////////////////////////////////////////

/*
 * TypePredicate is a unary predicate whose argument is bound to a value typed by a given type.
 */
@Bikeshed(heading="Rules")
class TypePredicate extends UnaryPredicate {
    /*
     * The type of a value
     */
    refers Type[1] ^type
}

/*
 * RelationEntityPredicate is a unary and binary predicate that holds when its argument is bound to an instance typed by the given relation 
 * entity, its argument1 is bound to the source of that relation instance and its argument2 is bound to the target of that relation instance
 * .
 */
@Bikeshed(heading="Rules")
class RelationEntityPredicate extends UnaryPredicate, BinaryPredicate {
    /*
     * The type of a relation instance
     */
    refers RelationEntity[1] ^type
}

////////////////////////////////////////
//  Binary Predicates
////////////////////////////////////////

/*
 * PropertyPredicate is a binary predicate that holds when its argument1 is bound to an instance and its argument2 is bound to a
 * a value of a given property on that instance.
 */
@Bikeshed(heading="Rules")
class PropertyPredicate extends BinaryPredicate {
    /*
     * The property of an instance 
     */
    refers Property[1] property
}

/*
 * SameAsPredicate is a binary predicate that holds when its two arguments are bound to the same instance
 */
@Bikeshed(heading="Rules")
class SameAsPredicate extends BinaryPredicate {
}

/*
 * DifferentFromPredicate is a binary predicate that holds when its two arguments are bound to different instances
 */
@Bikeshed(heading="Rules")
class DifferentFromPredicate extends BinaryPredicate {
}


////////////////////////////////////////
//  Literals
////////////////////////////////////////

/*
 * QuotedLiteral is a literal that specifies its lexical value as a quoted string along with a language tag, a scalar type, or neither.
 */
@Bikeshed(heading="Literals")
class QuotedLiteral extends Literal  {
    /*
     * The value of this literal represented as a string
     */
    String[1] value
    /*
     * The langTag of this literal
     */
    String[?] langTag
    /*
     * The scalar that is the type of this literal
     */
    refers Scalar[?] ^type
}

/*
 * IntegerLiteral is a literal that represents a 32-bit integer value
 */
@Bikeshed(heading="Literals")
class IntegerLiteral extends Literal  {
    /*
     * The int value of this literal
     */
    int value
}

/*
 * DecimalLiteral is a literal that represents an arbitrary precision decimal value
 */
@Bikeshed(heading="Literals")
class DecimalLiteral extends Literal  {
    /*
     * The decimal value of this literal
     */
    Decimal[1] value
}

/*
 * DoubleLiteral is a literal that represents a 64-bit double precision floating point value
 */
@Bikeshed(heading="Literals")
class DoubleLiteral extends Literal  {
    double value
}

/*
 * BooleanLiteral is a literal that represents the boolean values true/false
 */
@Bikeshed(heading="Literals")
class BooleanLiteral extends Literal {
    /*
     * The boolean value of this literal
     */
    boolean value
}

////////////////////////////////////////
//  Enumerations
////////////////////////////////////////

/*
 * SeparatorKind is an enumeration that specifies the separator character of an ontology's namespace. It can either
 * be only of two values: a hash '#' or a slash '/'.
 */
@Bikeshed(heading="Enumerations")
enum SeparatorKind {
    hash as '#' = 0
    slash as '/' = 1
}

/*
 * RangeRestrictionKind is an enumeration that specifies the scope of a range restriction on a property
 */
@Bikeshed(heading="Enumerations")
enum RangeRestrictionKind {
    /*
     * All values are restricted to the range
     */
    all = 0
    /*
     * Some values are restricted to the range
     */
    some = 1
}

/*
 * CardinalityRestrictionKind is an enumeration that specifies the kind of cardinality restriction on a property
 */
@Bikeshed(heading="Enumerations")
enum CardinalityRestrictionKind {
    /*
     * The cardinality must match this
     */
    exactly = 0
    /*
     * The cardinality is at least this
     */
    min = 1
    /*
     * The cardinality is at most this
     */
    max = 2
}

/*
 * ImportKind is an enumeration that specifies the kind of import
 */
@Bikeshed(heading="Enumerations")
enum ImportKind {
    /*
     * Extension is an import that allows an ontology to extend another of the same type. 
     */
    ^extension as "extends" = 0
    /*
 	 * Usage is an import that allows an ontology to use another of a different box type.
 	 */
    usage as "uses" = 1
    /*
	 * Inclusion is an import that allows a bundle ontology to include a non-bundle ontology of the same box type. 
     */
    inclusion as "includes" = 2
}

////////////////////////////////////////
//  Primitive Types
////////////////////////////////////////

@ExtendedMetaData(minInclusive="0", maxInclusive="4294967295")
type UnsignedInt wraps long

@ExtendedMetaData(minInclusive="0", maxInclusive="4294967295")
type UnsignedInteger wraps Long

@ExtendedMetaData(baseType="http://www.w3.org/2001/XMLSchema#decimal")
type Decimal wraps BigDecimal

@ExtendedMetaData(pattern="[a-zA-Z0-9_]([a-zA-Z0-9_\\-.$])*")
type ID wraps String

@ExtendedMetaData(pattern="([^\\s#])*(#|/)", minLength="2")
type Namespace wraps String
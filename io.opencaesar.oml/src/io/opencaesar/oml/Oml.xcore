/*
 * This Ecore package specifies the syntax (metamodel) of the Ontological Modeling Language. OML models are instances of 
 * this metamodel and can be manipulated using its API.     
 */
@Ecore(
    nsPrefix="oml",
    nsURI="http://opencaesar.io/oml"
)
@GenModel(
    copyrightText="\nCopyright 2019-2022 California Institute of Technology (\"Caltech\").\nU.S. Government sponsorship acknowledged.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n",
    modelDirectory="/io.opencaesar.oml/src-gen",
    editDirectory="/io.opencaesar.oml.edit/src-gen",
    //editorDirectory="/io.opencaesar.oml.editor/src-gen",
    importerID="org.eclipse.xsd.ecore.importer",
    complianceLevel="11.0"
)
@BikeshedHeadings(
    Elements="",
    Literals="",
    Vocabularies="",
    Types="",
    Properties="",
    Relations="",
    Predicates="",
    Axioms="",
    Descriptions="",
    Instances="",
    Assertions="",
    Enumerations=""
)
@Bikeshed(heading="Abstract-Syntax")
package io.opencaesar.oml

import io.opencaesar.oml.util.OmlConstants
import io.opencaesar.oml.util.OmlValidator2
import java.math.BigDecimal
import org.eclipse.emf.ecore.EDiagnosticChain
import org.eclipse.emf.ecore.EMap
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.InternalEObject
import org.eclipse.emf.common.util.BasicEList

annotation "https://tabatkins.github.io/bikeshed" as Bikeshed
annotation "https://tabatkins.github.io/bikeshed/headings" as BikeshedHeadings

////////////////////////////////////////
//  Root 
////////////////////////////////////////

/*
 * Element is the root supertype in OML. All objects in an OML ontology are elements.
 */
@Bikeshed(heading="Elements")
abstract class Element {
    /*
     * Gets the ontology that defines this element
     */
    op Ontology getOntology() {
        var EObject current = this
        while (current !== null && !(current instanceof Ontology)) {
            current = current.eContainer()
        }
        return current as Ontology
    }
    /*
     * Validates this element by extra validation rules
     * @param diagnostics validation error diagnostics
     * @param context object-to-object map used in producing messages 
     */
    op boolean extraValidate(EDiagnosticChain diagnostics, EMap<Object, Object>context) {
        return OmlValidator2.INSTANCE.run(this, diagnostics, context)
    }
}

////////////////////////////////////////
//  Elements 
////////////////////////////////////////

/*
 * Annotation is an element that specifies non-semantic information on an [=IdentifiedElement=]. 
 * An annotation is specified with an [=AnnotationProperty=] and an optional ([=Literal=] or [=Member=] reference) value. 
 * When no value is specified, the boolean literal `true` is assumed to be specified.
 */
@Bikeshed(heading="Elements")
class Annotation extends Element {
    /*
     * The annotation property specified by this annotation
     */
    refers AnnotationProperty[1] property
    /*
     * The literal value specified by this annotation
     */
    contains Literal[?] literalValue
    /*
     * The reference (to a member) value specified by this annotation
     */
    refers Member[?] referenceValue
    /*
     * The identified element that owns this annotation
     */
    container IdentifiedElement[?] owningElement opposite ownedAnnotations
    /*
     * Gets the value of the annotation
     */
    op Element getValue() {
    	if (literalValue !== null)
    		literalValue
    	else if (referenceValue !== null)
    		referenceValue
    }
    /*
     * Gets the identified element annotated by this annotation
     */
    op IdentifiedElement getAnnotatedElement() {
        if (owningElement instanceof Member) {
            return (owningElement as Member).resolve()
        }
        return owningElement
    }
}

/*
 * IdentifiedElement is an element that has a unique IRI (Internationalized Resource Identifier).
 * It can be annotated by a set of [=Annotations=].
 */
@Bikeshed(heading="Elements")
abstract class IdentifiedElement extends Element {
    /*
     * The set of annotations directly owned by this element
     */
    contains Annotation[*] ownedAnnotations opposite owningElement
    /*
     * Gets the IRI of this element 
     */ 
    op String getIri()
}

/*
 * Import is an element owned by an [=ontology=] and specifies that it imports another ontology.
 * The imported ontology is referenced by its namespace and an optional prefix that is locally unique 
 * within the importing ontology. Import can be of several [=ImportKind=] based on the following rules:
 * 
 * - Vocabulary (`extends` Vocabulary, `uses` Description)
 * - Description (`extends` Description, `uses` Vocabulary)
 * - VocabularyBundle (`extends` VocabularyBundle, `includes` Vocabulary)
 * - DescriptionBundle (`extends` DescriptionBundle, `includes` Description, `uses` VocabularyBundle, `uses` Vocabulary)
 */
@Bikeshed(heading="Elements")
class Import extends Element {
	/*
	 * The kind of this import
	 */
	ImportKind[1] kind
    /*
     * The namespace of the imported ontology
     */
    Namespace[1] namespace
    /*
     * The (locally unique) namespace prefix of the imported ontology
     */
    ID[?] prefix
    /*
     * The ontology that owns this import
     */
    container Ontology[1] owningOntology opposite ownedImports
    /*
     * Gets the imported ontology's IRI
     */
    op String getIri() {
    	if (namespace === null) {
    		return null
    	}
     	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
        	return namespace
       	} else {
       		return namespace.substring(0, i)
       	}
    }
    /*
     * Gets the imported ontology's namespace's separator character [=SeparatorKinds=]
     */
    op SeparatorKind getSeparator() {
     	if (namespace === null) {
    		return null
    	}
    	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
       		return null
       	} else {
        	return SeparatorKind.get(namespace.substring(i, i+1))
       	}
    }
}

/*
 * Instance is an element that represents a instance of one or more [=classifiers=]. 
 * It can assert a set of values for those classifiers' [=properties=].
 */
@Bikeshed(heading="Instances")
abstract class Instance extends Element {
    /*
     * The property value assertions owned by this instance
     */
    contains PropertyValueAssertion[*] ownedPropertyValues opposite owningInstance
}

/*
 * Axiom is an element that characterizes a [=term=] in some way.
 */
@Bikeshed(heading="Axioms")
abstract class Axiom extends Element {
	/*
	 * Gets the term that is characterized by this axiom
	 */
	op Term getCharacterizedTerm()
}

/*
 * Assertion is an element that characterizes an [=instance=] by specifying the value of one of its [=properties=].
 */
@Bikeshed(heading="Assertions")
abstract class Assertion extends Element {
    /**
     * Gets the instance that is the subject of this assertion
     */
    op Instance getSubject()
    /**
     * Gets the instance that is the object of this assertion
     */
    op Element getObject()
}

/*
 * Predicate is an element that represents a component of a [=rule=]'s antecedent or  consequent. 
 * It specifies (one or more) [=arguments=] based on the specific subtype of predicate.
 */
@Bikeshed(heading="Predicates")
abstract class Predicate extends Element {
    /*
     * The rule' antecedent that this predicate is owned by
     */
    container Rule[?] antecedentRule opposite antecedent
    /*
     * The rule' consequent that this predicate is owned by
     */
    container Rule[?] consequentRule opposite consequent
}

/*
 * Argument is an element that represents a variable name, a [=Literal=], or an [=NamedInstance=] specified in a [=predicate=].
 */
@Bikeshed(heading="Predicates")
class Argument extends Element {
    /*
     * An optional variable specified by this argument
     */
    ID[?] variable
    /*
     * An optional literal specified by this argument
     */
    contains Literal[?] literal
    /*
     * An optional instance specified by this argument
     */
    refers NamedInstance[?] instance
}

/*
 * Literal is an element that represents a literal value classified by a [=scalar=].
 */
@Bikeshed(heading="Literals")
abstract class Literal extends Element {
	/*
     * Gets the value of the given literal
	 */
    op Object getValue()
    /*
     * Gets the string value of the given literal
     */
    op String getStringValue() {
        return if (getValue() !== null) getValue().toString() else ""
    }
    /*
     * Gets the lexical value of the given literal
     */
    op String getLexicalValue() {
        return getStringValue()   
    }
    /*
     * Gets the iri of the given literal's type
     */
    op String getTypeIri()
}

////////////////////////////////////////
//  Identified Elements 
////////////////////////////////////////

/*
 * Ontology is an identified element that represents a namespace for its [=members=]. It is defined
 * by a globally unique namespace (an iri followed by either # or /) and an abbreviated prefix. 
 * An ontology can import other ontologies, and can make [=statements=] about its own as well as imported [=members=].
 */
@Bikeshed(heading="Elements")
abstract class Ontology extends IdentifiedElement {
    /*
     * The globally unique namespace of this ontology
     */
    Namespace[1] namespace
    /*
     * The prefix of this ontology's namespace
     */
    ID[1] prefix
    /*
     * The set of imports this ontology has to other ontologies
     */
    contains Import[*] ownedImports opposite owningOntology
    /*
     * Get the namespace's iri
     */
    op String getIri() {
    	if (namespace === null) {
    		return null
    	}
     	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
        	return namespace
       	} else {
       		return namespace.substring(0, i)
       	}
    }
    /*
     * Get the namespace's separator char
     */
    op SeparatorKind getSeparator() {
     	if (namespace === null) {
    		return null
    	}
    	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
       		return null
       	} else {
        	return SeparatorKind.get(namespace.substring(i, i+1))
       	}
    }
}

/*
 * Member is an identified element defined by an [=ontology=]. Its IRI is unique and derived by concatenating the globally
 * unique namespace of its ontology with its locally unique name (i.e., member.iri=ontology.namespace+member.name).
 */
@Bikeshed(heading="Elements")
abstract class Member extends IdentifiedElement {
    /*
     * A unique name for the member within its ontology
     */
    id ID[?] name
    
    /*
     * Gets the Ref of this member
     */
    op Member[?] getRef()
    /*
     * Determines if the member is a ref to another member
     */
    op boolean isRef() {
    	return getRef() !== null
    }
    /*
     * Determines if the member is a ref to another member
     */
    op Member[1] resolve() {
    	if (isRef()) {
    		return getRef()
    	}
    	return this
    }
    /*
     * Gets the IRI of this member
     */
    op String getIri() {
    	val m = resolve()
    	if (m.eIsProxy()) return (m as InternalEObject).eProxyURI().toString()
        val ontology = m.ontology
        val namespace = if (ontology !== null) ontology.namespace else SeparatorKind.HASH
        return namespace + if (m.name !== null) m.name else ''
    }
    /*
     * Gets the abbreviated IRI of this member
     */
    op String getAbbreviatedIri() {
     	val m = resolve()
    	if (m.eIsProxy()) return (m as InternalEObject).eProxyURI().toString()
        val ontology = m.ontology
        val prefix = if (ontology !== null) ontology.prefix  + ':' else ':'
        return prefix + if (m.name !== null) m.name else ''
    }
}

////////////////////////////////////////
//  Ontologies 
////////////////////////////////////////

/*
 * VocabularyBox is the supertype of [=Vocabulary=] and [=VocabularyBundle=].
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyBox extends Ontology {
}

/*
 * DescriptionBox is the supertype of [=Description=] and [=DescriptionBundle=].
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionBox extends Ontology {
}

////////////////////////////////////////
//  Vocabulary Boxes 
////////////////////////////////////////

/*
 * Vocabulary is a vocabulary box whose statements specify terms and rules in a given domain.
 */
@Bikeshed(heading="Vocabularies")
class Vocabulary extends VocabularyBox {
    /*
     * The set of statements contained by this vocabulary
     */
    contains VocabularyStatement[*] ownedStatements opposite owningVocabulary
}

/*
 * VocabularyBundle is a vocabulary box that closes the world on its imported [=vocabularies=] by considering their =terms=]
 * that do not have common specializations to be disjoint.
 */
@Bikeshed(heading="Vocabularies")
class VocabularyBundle extends VocabularyBox {
}

////////////////////////////////////////
//  Description Boxes 
////////////////////////////////////////

/*
 * Description is a description box whose statements specify instances in a given system.
 */
@Bikeshed(heading="Descriptions")
class Description extends DescriptionBox {
    /*
     * The set of statements contained by this description
     */
    contains DescriptionStatement[*] ownedStatements opposite owningDescription
}

/*
 * DescriptionBundle is a description box that closes the world on its imported [=descriptions=] by considering their [=instances=]
 * and their assertions to be the only ones available.
 */
@Bikeshed(heading="Descriptions")
class DescriptionBundle extends DescriptionBox {
}

////////////////////////////////////////
//  Members 
////////////////////////////////////////

/*
 * Statement is a [=member=] that is owned by an [=ontology=].  
 */
@Bikeshed(heading="Elements")
abstract class Statement extends Member {
}

/*
 * VocabularyMember is a [=member=] of a [=vocabulary=].
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyMember extends Member {
}

/*
 * DescriptionMember is a [=member=] of a [=description=].
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionMember extends Member {
}

////////////////////////////////////////
//  Statements
////////////////////////////////////////

/*
 * VocabularyStatement is a [=statement=] owned by a [=vocabulary=].
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyStatement extends Statement, VocabularyMember {
    /*
     * The vocabulary that owns this statement
     */
    container Vocabulary[1] owningVocabulary opposite ownedStatements
}

/*
 * DescriptionStatement is a [=statement=] owned by a [=description=].
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionStatement extends Statement, DescriptionMember {
    /*
     * The description that owns this statement
     */
    container Description[1] owningDescription opposite ownedStatements
}

////////////////////////////////////////
//  Vocabulary Members
////////////////////////////////////////

/*
 * Term is a [=member=] of a [=vocabulary=] that provides a particular semantic meaning when used in an [=assertion=].
 */
@Bikeshed(heading="Vocabularies")
abstract class Term extends VocabularyMember {
}

/*
 * Rule is a [=member=] of a [=vocabulary=] that adds a new inference rule to the set supported natively by DL. A rule must specify a set of one or
 * more antecedent [=predicates=] that forms a conjunction that infers, when it holds, a set of one or more consequent [=predicates=].
 */
@Bikeshed(heading="Vocabularies")
class Rule extends VocabularyStatement {
	/*
	 * A ref to another rule
	 */
	refers Rule ref
    /*
     * The set of predicates that form the antecedent of this rule
     */
    contains Predicate[*] antecedent opposite antecedentRule
    /*
     * The predicate that is the consequent of this rule
     */
    contains Predicate[*] consequent opposite consequentRule
}

/*
 * BuiltIn is a [=member=] of a [=vocabulary=] that represents a builtin function
 */
@Bikeshed(heading="Vocabularies")
class BuiltIn extends VocabularyStatement {
	/*
	 * A ref to another builtin
	 */
	refers BuiltIn ref
}

////////////////////////////////////////
//  Terms 
////////////////////////////////////////

/*
 * SpecializableTerm is a [=term=] that can be specialized by another term. It can have zero or more [=SpecializationAxioms=].
 */
@Bikeshed(heading="Vocabularies")
abstract class SpecializableTerm extends Term, VocabularyStatement {
    /*
     * The specialization axioms owned by this term
     */
    contains SpecializationAxiom[*] ownedSpecializations opposite owningTerm
}

/*
 * Property is a [=term=] that relates an [=instance=] to a value. It is the super type of all property types.
 */
@Bikeshed(heading="Properties")
abstract class Property extends Term {
}

////////////////////////////////////////
//  Specializable Terms
////////////////////////////////////////

/*
 * Type is a specializable term that classifies a set of [=instances=] or [=literals=].
 */
@Bikeshed(heading="Types")
abstract class Type extends SpecializableTerm {
}

/*
 * RelationBase is a specializable term that is the abstract superclass of a relation from a source [=entity=] to a target [=entity=].
 * It can optionally name a [=ReverseRelation=] whose domain is the target and whose range is the source. Such relation can only be
 * specified on a relation base definition not a ref to an existing one. A relation base can be characterized with several 
 * boolean flags that represent its DL semantics. Such flags apply conversely to the [=ReverseRelation=] (if named). 
 */
@Bikeshed(heading="Relations")
abstract class RelationBase extends SpecializableTerm {
    /*
     * The entities that represent the sources of this relation base
     */
    refers Entity[*] sources
    /*
     * The entities that represent the targets of this relation base
     */
    refers Entity[*] targets
    /*
     * The optional reverse relation of this relation base
     */
    contains ReverseRelation[?] reverseRelation opposite relationBase
    /*
     * Whether this relation base is functional (i.e., {@code A -> B and A->C => B=C})
     */
    boolean functional
    /*
     * Whether this relation base is inverse functional (i.e., {@code B->A and C->A => B=C})
     */
    boolean inverseFunctional
    /*
     * Whether this relation base is symmetric (i.e., {@code A->B => B->A})
     */
    boolean symmetric
    /*
     * Whether this relation base is asymmetric (i.e., {@code A->B => !(B->A)})
     */
    boolean asymmetric
    /*
     * Whether this relation base is reflexive (i.e., {@code A => A->A})
     */
    boolean reflexive
    /*
     * Whether this relation base is irreflexive (i.e., {@code A => !(A->A)})
     */
    boolean irreflexive
    /*
     * Whether this relation base is transitive (i.e., {@code A->B and B->C => A->C})
     */
    boolean transitive
}

/*
 * SpecializableProperty is a [=property=] that can be specialized. It can also specify [=PropertyEquivalenceAxioms=].
 */
@Bikeshed(heading="Properties")
abstract class SpecializableProperty extends SpecializableTerm, Property {
    /*
     * The set of property equivalence axioms of this property
     */
    contains PropertyEquivalenceAxiom[*] ownedEquivalences opposite owningProperty
}

////////////////////////////////////////
//  Types
////////////////////////////////////////

/*
 * Classifier is a [=type=] that classifies a set of [=instances=] and characterizes them with [=properties=]
 * (where it becomes a domain of these properties). it can also own a set of [=PropertyRestrictionAxioms=] as well as
 * set of [=ClassifierEquivalenceAxioms=].
 */
@Bikeshed(heading="Types")
abstract class Classifier extends Type {
    /*
     * The set of classifier equivalence axioms of this classifier
     */
    contains ClassifierEquivalenceAxiom[*] ownedEquivalences opposite owningClassifier
    /*
     * The set of property restriction axioms of this classifier
     */
    contains PropertyRestrictionAxiom[*] ownedPropertyRestrictions opposite owningClassifier
}

/*
 * Scalar is a primitive [=type=] that represents a set of [=literals=]. Some scalars are considered standard (see below).
 *  
 * A standard scalar can have specialization axioms to other standard scalars.
 * 
 * Non-standard scalars cannot have specialization axioms, but can have scalar equivalence axioms.
 * 
 * The standard scalars are:
 * 
 * <i>Numeric scalars</i>:
 * owl:real
 * owl:rational
 * xsd:decimal
 * xsd:integer
 * xsd:nonNegativeInteger
 * xsd:nonPositiveInteger
 * xsd:positiveInteger
 * xsd:negativeInteger
 * xsd:long
 * xsd:int
 * xsd:short
 * xsd:byte
 * xsd:unsignedLong
 * xsd:unsignedInt
 * xsd:unsignedShort
 * xsd:unsignedByte
 * xsd:double
 * xsd:float 
 * 
 * <i>Time scalars</i>:
 * xsd:dateTime
 * xsd:dateTimeStamp
 * 
 * <i>Plain scalars</i>:
 * rdf:PlainLiteral

 * <i>String scalars</i>:
 * xsd:string,
 * xsd:normalizedString,
 * xsd:token,
 * xsd:language,
 * xsd:Name,
 * xsd:NCName,
 * xsd:NMTOKEN
 * xsd:anyURI
 * 
 * <i>Boolean scalars</i>:
 * xsd:boolean
 * 
 * </i>Binary scalars}</i>:
 * xsd:hexBinary
 * xsd:base64Binary
 * 
 * <i>XML scalars</i>:
 * rdf:XMLLiteral
 */
@Bikeshed(heading="Types")
class Scalar extends Type {
	/*
	 * A ref to another scalar
	 */
	refers Scalar ref
	/*
	 * An enumeration of literals of this scalar
	 */
	contains LiteralEnumerationAxiom[?] ownedEnumeration opposite owningScalar
	/*
     * The set of scalar equivalence axioms of this scalar
	 */
	contains ScalarEquivalenceAxiom[*] ownedEquivalences opposite owningScalar
}

////////////////////////////////////////
//  Classifiers
////////////////////////////////////////

/*
 * Entity is a [=classifier=] whose instances are [=NamedInstances=]. It can also specify a set of [=KeyAxioms=]. 
 */
@Bikeshed(heading="Types")
abstract class Entity extends Classifier {
    /*
     * The unique keys of this entity
     */
    contains KeyAxiom[*] ownedKeys opposite owningEntity
}

/*
 * Structure is a [=classifier=] whose [=instances=] are anonymous and assignable as values to [=StructuredProperties=].
 */
@Bikeshed(heading="Types")
class Structure extends Classifier {
	/*
	 * A ref to another structure
	 */
	refers Structure ref
}

////////////////////////////////////////
//  Entities
////////////////////////////////////////

/*
 * Aspect is an =[entity=] that represents a capability that may be specified on multiple [=concepts=]. 
 * An aspect can only specialize other aspects. It can also be specified as a type of [=NamedInstances=].
 * Aspects are not considered disjoint in a vocabulary bundle. 
 */
@Bikeshed(heading="Types")
class Aspect extends Entity {
	/*
	 * A ref to another aspect
	 */
	refers Aspect ref
}

/*
 * Concept is an [=entity=] that represents a concept in some domain. 
 * It can only specialize other concepts of [=aspects=]. It can also be specified as a type of [=ConceptInstances=].
 * Concepts with no common subtypes are considered disjoint in a vocabulary bundle. 
 */
@Bikeshed(heading="Types")
class Concept extends Entity {
	/*
	 * A ref to another concept
	 */
	refers Concept ref
	/*
	 * An enumeration of instances of this concept
	 */
	contains InstanceEnumerationAxiom[?] ownedEnumeration opposite owningConcept
}

/*
 * RelationEntity is an [=entity=] that represents a reified relation from a source entity to a target entity. 
 * It can optionally name a [=ForwardRelation=] whose domain is the source and whose range is the target.
 * If both are named, such [=ForwardRelation=] becomes the inverse of the entity's [=ReverseRelation=] . 
 * If not, then a default [=ForwardRelation=]  with the name 'has<Relation>Forward' is assumed. 
 * A relation entity ref cannot specify a [=ForwardRelation=].
 */
@Bikeshed(heading="Relations")
class RelationEntity extends Entity, RelationBase {
	/*
	 * A ref to another relation entity
	 */
	refers RelationEntity ref
    /*
     * The optional forward relation of this relation entity
     */
    contains ForwardRelation[?] forwardRelation opposite relationEntity
}

////////////////////////////////////////
//  Properties
////////////////////////////////////////

/*
 * AnnotationProperty is a [=SpecializableProperty=] with no DL semantics.
 */
@Bikeshed(heading="Properties")
class AnnotationProperty extends SpecializableProperty {
	/*
	 * A ref to another annotation property
	 */
	refers AnnotationProperty ref
}

/*
 * SemanticProperty is a [=property=] with DL semantics that relates a [=classifier=] acting as its
 * domain to a [=type=] acting as its range.
 */
@Bikeshed(heading="Properties")
abstract class SemanticProperty extends Property {
    /*
     * Determines if this property is functional (has a max of one value per instance) 
     */
    op boolean isFunctional()
    /*
     * Gets the domains of this property
     */
    op Classifier[] getDomainList()
    /*
     * Gets the ranges of this property
     */
    op Type[] getRangeList()
}

////////////////////////////////////////
//  Semantic Properties
////////////////////////////////////////

/*
 * ScalarProperty is a [=SemanticProperty=] whose range is a [=Scalar=]. It can specialize other [=ScalarProperties=].
 */
@Bikeshed(heading="Properties")
class ScalarProperty extends SemanticProperty, SpecializableProperty {
	/*
	 * A ref to another scalar property
	 */
	refers ScalarProperty ref
    /*
     * Whether this property is functional (has a max of one value per instance) 
     */
    boolean functional
    /*
     * The classifier that is the domain of this property
     */
    refers Classifier[*] domains
    /*
     * The scalar that is the range of this property
     */
    refers Scalar[*] ranges

    op Classifier[] getDomainList() {
    	domains
    }
    op Type[] getRangeList() {
    	new BasicEList(ranges)
    }
}

/*
 * StructuredProperty is a [=SemanticProperty=] whose range is a [=Structure=]. It can specialize other [=StructuredProperties=].
 */
@Bikeshed(heading="Properties")
class StructuredProperty extends SemanticProperty, SpecializableProperty {
	/*
	 * A ref to another structured property
	 */
	refers StructuredProperty ref
    /*
     * Whether this property is functional (has a max of one value per instance) 
     */
    boolean functional
    /*
     * The classifiers that are the domains of this property
     */
    refers Classifier[*] domains
    /*
     * The structures that are the range of this property
     */
    refers Structure[*] ranges

    op Classifier[] getDomainList() {
    	domains
    }
    op Type[] getRangeList() {
    	new BasicEList(ranges)
    }
}

/*
 * Relation is a [=SemanticProperty=] whose domain is an [=Entity=] and whose range is also an [=Entity=].
 * It can be characterized by DL flags and can have an inverse [=Relation=].
 */
@Bikeshed(heading="Properties")
abstract class Relation extends SemanticProperty {
    /*
     * Gets whether this relation is inverse functional (i.e., {@code B->A and C->A => B=C})
     */
    op boolean isInverseFunctional()
    /*
     * Gets whether this relation is symmetric (i.e., {@code A->B => B->A})
     */
    op boolean isSymmetric()
    /*
     * Gets whether this relation is asymmetric (i.e., {@code A->B => !(B->A)})
     */
    op boolean isAsymmetric()
    /*
     * Gets whether this relation is reflexive (i.e., {@code A => A->A})
     */
    op boolean isReflexive()
    /*
     * Gets whether this relation is irreflexive (i.e., {@code A => !(A->A)})
     */
    op boolean isIrreflexive()
    /*
     * Gets whether this relation is transitive (i.e., {@code A->B and B->C => A->C})
     */
    op boolean isTransitive()
    /*
     * Gets the domain of this relation
     */
    op Entity[*] getDomains()
    /*
     * Gets the range of the relation
     */
    op Entity[*] getRanges()
    /*
     * Gets the inverse of this relation
     */
    op Relation[?] getInverse()

    op Classifier[] getDomainList() {
    	new BasicEList(getDomains())
    }
    op Type[] getRangeList() {
    	new BasicEList(getRanges())
    }
}

////////////////////////////////////////
//  Relations
////////////////////////////////////////

/*
 * ForwardRelation is a [=Relation=] that is defined by a [=RelationEntity=]. Its domains are the sources of the [=RelationEntity=], 
 * and its ranges are the targets of the [=RelationEntity=]. The DL semantics of a forward property are the same as those 
 * of its [=RelationEntity=].
 */
@Bikeshed(heading="Relations")
class ForwardRelation extends Relation {
    /*
     * The relation entity that owns this forward property
     */
    container RelationEntity[1] relationEntity opposite forwardRelation
    
    op Member getRef() {
    	null
    }
    op boolean isFunctional() {
        relationEntity.functional
	}
    op boolean isInverseFunctional() {
        relationEntity.inverseFunctional
    }
    op boolean isSymmetric() {
        relationEntity.symmetric
    }
    op boolean isAsymmetric() {
        relationEntity.asymmetric
    }
    op boolean isReflexive() {
        relationEntity.reflexive
    }
    op boolean isIrreflexive() {
        relationEntity.irreflexive
    }
    op boolean isTransitive() {
        relationEntity.transitive
    }
    op Entity[*] getDomains() {
		relationEntity.sources
    }
    op Entity[*] getRanges() {
		relationEntity.targets
    }
    op Relation getInverse() {
		relationEntity.reverseRelation
    }
}

/*
 * ReverseRelation is a [=Relation=] that is defined by a [=RelationBase=] and represents its inverse [=relation=]. Its domain
 * is the target of the [=RelationBase=], and its range is the source of the [=RelationBase=]. The DL semantics of a reverse property are 
 * derived from those of its [=RelationBase=].
 */
@Bikeshed(heading="Relations")
class ReverseRelation extends Relation {
    /*
     * The relation that owns this reverse property
     */
    container RelationBase[1] relationBase opposite reverseRelation
    
    op Member getRef() {
    	null
    }
    op boolean isFunctional() {
        relationBase.inverseFunctional
	}
    op boolean isInverseFunctional() {
        relationBase.inverseFunctional
    }
    op boolean isSymmetric() {
        relationBase.symmetric
    }
    op boolean isAsymmetric() {
        relationBase.asymmetric
    }
    op boolean isReflexive() {
        relationBase.reflexive
    }
    op boolean isIrreflexive() {
       relationBase.irreflexive
    }
    op boolean isTransitive() {
        relationBase.transitive
    }
    op Entity[*] getDomains() {
        relationBase.targets
    }
    op Entity[*] getRanges() {
        relationBase.sources
    }
    op Relation getInverse() {
        if (relationBase instanceof RelationEntity)
            (relationBase as RelationEntity).forwardRelation
        else if (relationBase instanceof Relation)
        	relationBase as Relation
    }
}

/*
 * UnreifiedRelation is a simple [=relation=] from a source [=entity=] to a target [=entity=]. 
 */
@Bikeshed(heading="Relations")
class UnreifiedRelation extends Relation, RelationBase, SpecializableProperty {
	/*
	 * A ref to another relation
	 */
	refers Relation ref

    op Entity[*] getDomains() {
        sources
    }
    op Entity[*] getRanges() {
    	targets
    }
    op Relation getInverse() {
		reverseRelation
    }
}

////////////////////////////////////////
//  Description Members
////////////////////////////////////////

/*
 * NamedInstance is an [=Instance=] that is a member of a [=description=].
 */
@Bikeshed(heading="Instances")
abstract class NamedInstance extends DescriptionStatement, Instance {
    /*
     * The types of this instance
     */
    contains TypeAssertion[*] ownedTypes opposite owningInstance
}

////////////////////////////////////////
//  Named Instances
////////////////////////////////////////

/*
 * ConceptInstance is a [=NamedInstance=] that can be typed by [=Concepts=] or [=Aspects=].
 */
@Bikeshed(heading="Instances")
class ConceptInstance extends NamedInstance {
	/*
	 * A ref to another concept instance
	 */
	refers ConceptInstance ref
}

/*
 * RelationInstance is a [=NamedInstance=] that can be typed by [=RelationEntities=] and represents a link from one or 
 * more [=NamedInstances=] as sources to one or more [=NamedInstances=] as targets.
 */
@Bikeshed(heading="Instances")
class RelationInstance extends NamedInstance {
	/*
	 * A ref to another relation instance
	 */
	refers RelationInstance ref
    /*
     * The named instances that are the sources of this relation instance
     */
    refers NamedInstance[*] sources
    /*
     * The named instances that are the targets of this relation instance
     */
    refers NamedInstance[*] targets
}

////////////////////////////////////////
//  Instances
////////////////////////////////////////

/*
 * StructureInstance is an [=Instance=] that can be typed by a [=Structure=]. It is anonymous and gets assigned as a value of a [=StructuredProperty=]
 * either in a [=PropertyValueRestrictionAxiom=] or a [=PropertyValueAssertion=].
 */
@Bikeshed(heading="Instances")
class StructureInstance extends Instance {
    /*
     * The type of this instance
     */
    refers Structure[1] ^type
    /*
     * The property value restriction axiom that assigns this instance as a restricted value
     */
    container PropertyValueRestrictionAxiom[?] owningAxiom opposite structureInstanceValue
    /*
     * The property value assertion that assigns this instance as a value
     */
    container PropertyValueAssertion[?] owningAssertion opposite structureInstanceValue
}

////////////////////////////////////////
//  Axioms
////////////////////////////////////////

/*
 * KeyAxiom is an [=Axiom=] that specifies that a set of [=properties=] form a unique key for an [=entity=]. This means that all 
 * [=instances=] of that [=entity=] must have unique values for those keys.
 */
@Bikeshed(heading="Axioms")
class KeyAxiom extends Axiom {
    /*
     * The set of key properties specified by this axiom
     */
    refers Property[+] properties
    /*
     * The owning entity specified by this axiom
     */
    container Entity[?] owningEntity opposite ownedKeys
    /*
     * Gets the entity that defines the given key axiom
     */
    op Entity getKeyedEntity() {
    	return owningEntity.resolve() as Entity
    }
    
	op Entity getCharacterizedTerm() {
		getKeyedEntity()
	}
}

/*
 * SpecializationAxiom is an [=Axiom=] specified on a [=SpecializableTerm=] that states that it specializes another [=Term=].
 */
@Bikeshed(heading="Axioms")
class SpecializationAxiom extends Axiom {
    /*
     * The super term specified by this axiom
     */
    refers Term[1] superTerm
    /*
     * The owning term specified by this axiom
     */
    container SpecializableTerm[?] owningTerm opposite ownedSpecializations
    /*
     * Gets the sub (specific) term of the given specialization axiom
     */
    op Term getSubTerm() {
    	return owningTerm.resolve() as Term
    }

	op Term getCharacterizedTerm() {
		getSubTerm()
	}
}

/*
 * InstanceEnumerationAxiom is an [=Axiom=] specified on a [=Concept=] that states that it classifies an enumerated set of [=instances=].
 */
@Bikeshed(heading="Axioms")
class InstanceEnumerationAxiom extends Axiom {
	/*
	 * The set of enumerated instances specified by this axiom
	 */
	refers ConceptInstance[+] instances
    /*
     * The owning concept specified by this axiom
     */
    container Concept[?] owningConcept opposite ownedEnumeration
    /*
     * Gets the concept that defines the given enumeration axiom
     */
    op Concept getEnumeratedConcept() {
    	return owningConcept.resolve() as Concept
    }

	op Concept getCharacterizedTerm() {
		getEnumeratedConcept()
	}
}

/*
 * PropertyRestrictionAxiom is an [=Axiom=] specified on a [=Classifier=] that places some restriction on the value of a [=SemanticProperty=] 
 * in the context of the classifier.
 */
@Bikeshed(heading="Axioms")
abstract class PropertyRestrictionAxiom extends Axiom {
    /*
     * The restricted property specified by this axiom
     */
    refers SemanticProperty[1] property
    /*
     * The owning classifier specified by this axiom
     */
    container Classifier[?] owningClassifier opposite ownedPropertyRestrictions
    /*
     * The owning classifier equivalence axiom specified by this axiom
     */
    container ClassifierEquivalenceAxiom[?] owningAxiom opposite ownedPropertyRestrictions
    /*
     * Gets the restricting domain of the given property restriction axiom
     */
    op Classifier getRestrictingDomain() {
    	if (owningAxiom !== null) {
    		return owningAxiom.subClassifier
   		}
    	return owningClassifier.resolve() as Classifier
    }
    
	op Classifier getCharacterizedTerm() {
		getRestrictingDomain()
	}
}

/*
 * LiteralEnumerationAxiom is an [=Axiom=] specified on a [=Scalar=] that states that it classifies an enumerated set of [=Literals=].
 */
@Bikeshed(heading="Axioms")
class LiteralEnumerationAxiom extends Axiom {
	/*
	 * The set of enumerated literals specified by this axiom
	 */
	contains Literal[+] literals
    /*
     * The owning scalar specified by this axiom
     */
    container Scalar[?] owningScalar opposite ownedEnumeration
    /*
     * Gets the scalar that defines the given enumeration axiom
     */
    op Scalar getEnumeratedScalar() {
    	return owningScalar.resolve() as Scalar
    }

	op Scalar getCharacterizedTerm() {
		getEnumeratedScalar()
	}
}

/*
 * ClassifierEquivalenceAxiom is an [=Axiom=] specified on a subject [=Classifier=] that states that it is equivalent to the intersection
 * of [=Classifiers=] and/or [=PropertyRestrictionAxioms=]. This axiom implies that the [=classifiers=] are super types of the subject classifier. 
 * It also implies that when an instance is classified by this intersection, then it follows that it is also classified by the 
 * subject classifier. Conversely, when an instance is classified by the subject classifier, then it follows that it is also classified 
 * by the intersection. In other words, this axiom enables bi-directional (or two-way) inferencing.
 */
@Bikeshed(heading="Axioms")
class ClassifierEquivalenceAxiom extends Axiom {
    /*
     * The super classifiers specified by this axiom
     */
    refers Classifier[*] superClassifiers
    /*
     * The property restrictions specified by this axiom
     */
    contains PropertyRestrictionAxiom[*] ownedPropertyRestrictions opposite owningAxiom
    /*
     * The owning classifier specified by this axiom
     */
    container Classifier[?] owningClassifier opposite ownedEquivalences
    /*
     * Gets the sub classifier of this axiom
     */
    op Classifier getSubClassifier() {
    	return owningClassifier.resolve() as Classifier
    }

	op Classifier getCharacterizedTerm() {
		getSubClassifier()
	}
}

/*
 * ScalarEquivalenceAxiom is an [=Axiom=] specified on a subject [=Scalar=] that states that it is equivalent to another
 * [=Scalar=]. When the equivalent scalar is one of the standard scalars (see {@link Scalar}), the equivalence may specify 
 * some restriction facets. The applicable facets depend on the restricted standard scalar (see below).  
 * 
 * This axiom implies that the subject scalar is a subtype of the equivalent scalar. When there are no facets specified, 
 * then it also implies that the equivalent scalar is also a subtype of the subject scalar. 
 * 
 * The following is the set of allowed facets for each standard scalar:
 *   
 * Numeric scalars (facets: minInclusive, maxInclusive, minExclusive, maxExclusive, literals):
 * Time scalars (facets: minInclusive, maxInclusive, minExclusive, maxExclusive, literals):
 * Plain scalars (facets: length, minLength, maxLength, pattern, language, literals):
 * String scalars (facets: length, minLength, maxLength, pattern, literals)
 * Binary scalars (facets: length, minLength, maxLength, literals):
 */
@Bikeshed(heading="Axioms")
class ScalarEquivalenceAxiom extends Axiom {
    /*
     * The super scalar specified by this axiom
     */
    refers Scalar[1] superScalar
    /*
     * The owning scalar specified by this axiom
     */
    container Scalar[1] owningScalar opposite ownedEquivalences
    /*
     * The exact length of the literals of this scalar
     */
    UnsignedInteger[?] length
    /*
     * The minimum length of the literals of this scalar
     */
    UnsignedInteger[?] minLength
    /*
     * The maximum length of the literals of this scalar
     */
    UnsignedInteger[?] maxLength
    /*
     * The pattern that the literals of this scalar conforms to
     */
    String[?] pattern
    /*
     * The language range that the literals of this scalar belong to 
     * (based on http://www.rfc-editor.org/rfc/bcp/bcp47.txt)
     */
    String[?] language
    /*
     * The minimum inclusive value of numeric literals of this scalar
     */
    contains Literal[?] minInclusive
    /*
     * The minimum exclusive value of numeric literals of this scalar
     */
    contains Literal[?] minExclusive
    /*
     * The maximum inclusive value of numeric literals of this scalar
     */
    contains Literal[?] maxInclusive
    /*
     * The maximum exclusive value of numeric literals of this scalar
     */
    contains Literal[?] maxExclusive
    /*
     * Gets the sub scalar of this axiom
     */
    op Scalar getSubScalar() {
    	return owningScalar.resolve() as Scalar
    }

	op Scalar getCharacterizedTerm() {
		getSubScalar()
	}
}

/*
 * PropertyEquivalenceAxiom is an [=Axiom=] specified on a subject [=Property=] that states that it is equivalent 
 * to another property. This axiom implies that the equivalent properties are super properties of the subject property 
 * (and vice versa).
 */
@Bikeshed(heading="Axioms")
class PropertyEquivalenceAxiom extends Axiom {
    /*
     * The super property specified by this axiom
     */
    refers Property[1] superProperty
    /*
     * The owning property specified by this axiom
     */
    container SpecializableProperty[?] owningProperty opposite ownedEquivalences
    /*
     * Gets the sub property of this axiom
     */
    op Property getSubProperty() {
    	return owningProperty.resolve() as Property
    }

	op Property getCharacterizedTerm() {
		getSubProperty()
	}
}


////////////////////////////////////////
//  Property Restriction Axioms
////////////////////////////////////////

/*
 * PropertyRangeRestrictionAxiom is a [=PropertyRestrictionAxiom=] that restricts the range of a [=property=] to
 * a [=type=] that specializes the original range. This restrictions may apply to `all` or to `some` values of the property
 * that have the restricting [=classifier=] as a domain.
 */
@Bikeshed(heading="Axioms")
class PropertyRangeRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * The range restriction kind specified by this axiom (default is all)
     */
    RangeRestrictionKind[1] kind = "all" 
    /*
     * The restricted range specified by this axiom
     */
    refers Type[1] range
}

/*
 * PropertyCardinalityRestrictionAxiom is a [=PropertyRestrictionAxiom=] that restricts the cardinality of a [=property=]
 * to an exact value, a minimum value or a maximum value. This restrictions can apply either to all values of the property 
 * in the restricting [=classifier=], or only to those values classified by a specific subtype of the range.
 */
@Bikeshed(heading="Axioms")
class PropertyCardinalityRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * The kind of cardinality restriction specified by this axiom (default is exactly)
     */
    CardinalityRestrictionKind[1] kind = "exactly"
    /*
     * The value of the cardinality specified by this axiom (default is 1)
     */
    UnsignedInt[1] cardinality = "1"
    /*
     * The optional restricted range specified by this axiom
     */
    refers Type[?] range
}

/*
 * PropertyValueRestrictionAxiom is a [=PropertyRestrictionAxiom=] that restricts a [=property=] in a given domain to a specific
 * value. The value is either a [=literal=] value in the case of a [=ScalarProperty=], a contained [=StructureInstance=] value 
 * in the case of a [=StructuredProperty=], or a reference to a ([=NamedInstance=] value in the case of a [=Relation=].
 */
@Bikeshed(heading="Axioms")
class PropertyValueRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * A restricted literal value (of a scalar property) 
     */
    contains Literal[?] literalValue
    /*
     * A restricted structure instance value (of a structured property) 
     */
    contains StructureInstance[?] structureInstanceValue opposite owningAxiom
    /*
     * A restricted named instance value (of a relation) 
     */
    refers NamedInstance[?] namedInstanceValue
    /*
     * Gets the restricted value
     */
    op Element getValue() {
    	if (property instanceof ScalarProperty)
    		literalValue
    	else if (property instanceof StructuredProperty)
    		structureInstanceValue
    	else if (property instanceof Relation)
    		namedInstanceValue
    }
}

/*
 * PropertySelfRestrictionAxiom is a [=PropertyRestrictionAxiom=] that restricts a [=property=] in a given domain to be related to
 * itself only.
 */
@Bikeshed(heading="Axioms")
class PropertySelfRestrictionAxiom extends PropertyRestrictionAxiom {
}

////////////////////////////////////////
//  Assertions
////////////////////////////////////////

/*
 * TypeAssertion is an [=Assertion=] that specifies a type for a [=NamedInstance=]. 
 */
@Bikeshed(heading="Assertions")
class TypeAssertion extends Assertion {
    /*
     * The type of the instance owning this assertion
     */
    refers Entity[1] ^type
    /*
     * The instance that owns this assertion
     */
    container NamedInstance[?] owningInstance opposite ownedTypes

    op NamedInstance getSubject() {
    	return owningInstance.resolve() as NamedInstance
    }
    op Element getObject() {
    	return ^type
    }
}

/*
 * PropertyValueAssertion is an [=Assertion=]  that specifies a value for a [=property=] on an [=instance=]. The value is either a [=literal=] value 
 * in the case of a [=ScalarProperty=], a contained [=StructureInstance=] value in the case of a [=StructuredProperty=], or a reference to a 
 * [=NamedInstance=] value in the case of a [=Relation=].
 */
@Bikeshed(heading="Assertions")
class PropertyValueAssertion extends Assertion {
    /*
     * The property referenced by this assertion
     */
    refers SemanticProperty[1] property
    /*
     * An asserted literal value of a scalar property 
     */
    contains Literal[?] literalValue
    /*
     * An asserted structure instance value of a structured property 
     */
    contains StructureInstance[?] structureInstanceValue opposite owningAssertion
    /*
     * An asserted named instance value of a relation 
     */
    refers NamedInstance[?] namedInstanceValue
    /*
     * The instance that this property value assertion is about
     */
    container Instance[?] owningInstance opposite ownedPropertyValues
    /*
     * Gets the asserted value
     */
    op Element getValue() {
    	if (property instanceof ScalarProperty)
    		literalValue
    	else if (property instanceof StructuredProperty)
    		structureInstanceValue
    	else if (property instanceof Relation)
    		namedInstanceValue
    }

    op Instance getSubject() {
        if (owningInstance instanceof NamedInstance) {
            return (owningInstance as NamedInstance).resolve() as NamedInstance
        }
        return owningInstance
    }
    op Element getObject() {
    	return getValue()
    }
}

////////////////////////////////////////
//  Predicates
////////////////////////////////////////

/*
 * UnaryPredicate is a [=Predicate=] that has one [=argument=].
 */
@Bikeshed(heading="Predicates")
abstract class UnaryPredicate extends Predicate {
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument
}

/*
 * BinaryPredicate is a [=Predicate=] that has two [=arguments=]: argument1 and argument2
 */
@Bikeshed(heading="Predicates")
abstract class BinaryPredicate extends Predicate {
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument1
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument2
}

/*
 * BuiltInPredicate is a [=Predicate=] that has two [=arguments=]: argument1 and argument2
 */
@Bikeshed(heading="Predicates")
class BuiltInPredicate extends Predicate {
    /*
     * The called builtin
     */
    refers BuiltIn[1] builtIn
    /*
     * An argument of the predicate
     */
    contains Argument[+] arguments
}

////////////////////////////////////////
//  Unary Predicates
////////////////////////////////////////

/*
 * TypePredicate is a [=UnaryPredicate=] whose [=argument=] is bound to a value typed by a given [=type=].
 */
@Bikeshed(heading="Predicates")
class TypePredicate extends UnaryPredicate {
    /*
     * The type of a value
     */
    refers Type[1] ^type
}

/*
 * RelationEntityPredicate is a [=UnaryPredicate=] and [=BinaryPredicate=] that holds when its [=argument=] is bound to an [=RelationInstance=] typed by the given [=RelationEntity=], 
 * its argument1 is bound to the source of that [=RelationInstance=] and its argument2 is bound to the target of that [=RelationInstance=]
 * .
 */
@Bikeshed(heading="Predicates")
class RelationEntityPredicate extends UnaryPredicate, BinaryPredicate {
    /*
     * The type of a relation instance
     */
    refers RelationEntity[1] ^type
}

////////////////////////////////////////
//  Binary Predicates
////////////////////////////////////////

/*
 * PropertyPredicate is a [=BinaryPredicate=] that holds when its argument1 is bound to an [=NamedInstance=] and its argument2 is bound to a
 * a value of a given [=property=] on that instance.
 */
@Bikeshed(heading="Predicates")
class PropertyPredicate extends BinaryPredicate {
    /*
     * The property of an instance 
     */
    refers Property[1] property
}

/*
 * SameAsPredicate is a [=BinaryPredicate=] that holds when its two [=arguments=] are bound to the same [=NamedInstance=].
 */
@Bikeshed(heading="Predicates")
class SameAsPredicate extends BinaryPredicate {
}

/*
 * DifferentFromPredicate is a [=BinaryPredicate=] that holds when its two [=arguments=] are bound to different [=NamedInstances=].
 */
@Bikeshed(heading="Predicates")
class DifferentFromPredicate extends BinaryPredicate {
}


////////////////////////////////////////
//  Literals
////////////////////////////////////////

/*
 * QuotedLiteral is a [=literal=] that specifies its lexical value as a quoted string along with a language tag, a [=Scalar=] type, or neither.
 */
@Bikeshed(heading="Literals")
class QuotedLiteral extends Literal  {
    /*
     * The value of this literal represented as a string
     */
    String[1] value
    /*
     * The langTag of this literal
     */
    String[?] langTag
    /*
     * The scalar that is the type of this literal
     */
    refers Scalar[?] ^type

    op String getLexicalValue() {
        return '"'+value+'"' + if (getLangTag !== null) "$"+getLangTag else "^^<"+ getTypeIri() + ">"
    }
    op String getTypeIri() {
    	return if (^type !== null) ^type.getIri() else OmlConstants.XSD_NS+"string" 
    }
}

/*
 * IntegerLiteral is a [=literal=] that represents a 32-bit integer value.
 */
@Bikeshed(heading="Literals")
class IntegerLiteral extends Literal  {
    /*
     * The int value of this literal
     */
    Integer value = "0"

    op String getTypeIri() {
    	return OmlConstants.XSD_NS+"integer" 
    }
}

/*
 * DecimalLiteral is a [=literal=] that represents an arbitrary precision decimal value.
 */
@Bikeshed(heading="Literals")
class DecimalLiteral extends Literal  {
    /*
     * The decimal value of this literal
     */
    Decimal[1] value = "0.0"

    op String getTypeIri() {
    	return OmlConstants.XSD_NS+"decimal" 
    }
}

/*
 * DoubleLiteral is a [=literal=] that represents a 64-bit double precision floating point value.
 */
@Bikeshed(heading="Literals")
class DoubleLiteral extends Literal  {
    /*
     * The double value of this literal
     */
    Double value = "0.0"

    op String getTypeIri() {
    	return OmlConstants.XSD_NS+"double" 
    }
}

/*
 * BooleanLiteral is a [=literal=] that represents the boolean values `true` and `false`.
 */
@Bikeshed(heading="Literals")
class BooleanLiteral extends Literal {
    /*
     * The boolean value of this literal
     */
    Boolean value = "false"
    
    op boolean isValue() {
    	return getValue().booleanValue
    }

    op String getTypeIri() {
    	return OmlConstants.XSD_NS+"boolean" 
    }
}

////////////////////////////////////////
//  Enumerations
////////////////////////////////////////

/*
 * SeparatorKind is an enumeration that specifies the separator character of an ontology's namespace. It can be one of two values: # or /.
 */
@Bikeshed(heading="Elements")
enum SeparatorKind {
    hash as '#' = 0
    slash as '/' = 1
}

/*
 * RangeRestrictionKind is an enumeration that specifies the scope of a [=PropertyRangeRestrictionAxiom=].
 */
@Bikeshed(heading="Properties")
enum RangeRestrictionKind {
    /*
     * All values are restricted to the range
     */
    all = 0
    /*
     * Some values are restricted to the range
     */
    some = 1
}

/*
 * CardinalityRestrictionKind is an enumeration that specifies the kind of [=PropertyCardinalityRestrictionAxiom=] on a [=property=].
 */
@Bikeshed(heading="Properties")
enum CardinalityRestrictionKind {
    /*
     * The cardinality must match this
     */
    exactly = 0
    /*
     * The cardinality is at least this
     */
    min = 1
    /*
     * The cardinality is at most this
     */
    max = 2
}

/*
 * ImportKind is an enumeration that specifies the kind of =[import=].
 */
@Bikeshed(heading="Elements")
enum ImportKind {
    /*
     * Extension is an import that allows an ontology to extend another of the same type. 
     */
    ^extension as "extends" = 0
    /*
 	 * Usage is an import that allows an ontology to use another of a different box type.
 	 */
    usage as "uses" = 1
    /*
	 * Inclusion is an import that allows a bundle ontology to include a non-bundle ontology of the same box type. 
     */
    inclusion as "includes" = 2
}

////////////////////////////////////////
//  Primitive Types
////////////////////////////////////////

@ExtendedMetaData(minInclusive="0", maxInclusive="4294967295")
type UnsignedInt wraps long

@ExtendedMetaData(minInclusive="0", maxInclusive="4294967295")
type UnsignedInteger wraps Long

@ExtendedMetaData(baseType="http://www.w3.org/2001/XMLSchema#decimal")
type Decimal wraps BigDecimal

@ExtendedMetaData(pattern="[a-zA-Z0-9_]([a-zA-Z0-9_\\-.$])*")
type ID wraps String

@ExtendedMetaData(pattern="([^\\s#])*(#|/)", minLength="2")
type Namespace wraps String
/*
 * This Ecore package specifies the syntax (metamodel) of the Ontological Modeling Language. OML models are instances of 
 * this metamodel and can be manipulated using its API.     
 */
@Ecore(
    nsPrefix="oml",
    nsURI="http://opencaesar.io/oml"
)
@GenModel(
    copyrightText="\nCopyright 2019-2022 California Institute of Technology (\"Caltech\").\nU.S. Government sponsorship acknowledged.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n",
    modelDirectory="/io.opencaesar.oml/src-gen",
    editDirectory="/io.opencaesar.oml.edit/src-gen",
    //editorDirectory="/io.opencaesar.oml.editor/src-gen",
    importerID="org.eclipse.xsd.ecore.importer",
    complianceLevel="11.0"
)
@BikeshedHeadings(
    Elements="",
    Literals="",
    Vocabularies="",
    Types="",
    Properties="",
    Rules="",
    Axioms="",
    Descriptions="",
    Instances="",
    Assertions="",
    Enumerations=""
)
@Bikeshed(heading="Abstract-Syntax")
package io.opencaesar.oml

import io.opencaesar.oml.util.OmlConstants
import io.opencaesar.oml.util.OmlValidator2
import java.math.BigDecimal
import org.eclipse.emf.ecore.EDiagnosticChain
import org.eclipse.emf.ecore.EMap
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.InternalEObject
import org.eclipse.emf.common.util.BasicEList

annotation "https://tabatkins.github.io/bikeshed" as Bikeshed
annotation "https://tabatkins.github.io/bikeshed/headings" as BikeshedHeadings

////////////////////////////////////////
//  Root 
////////////////////////////////////////

/*
 * Element is the most general type in the OML metamodel. All objects in an OML model are elements.
 */
@Bikeshed(heading="Elements")
abstract class Element {
    /*
     * Validates this element by extra validation rules
     * @param diagnostics validation error diagnostics
     * @param context object-to-object map used in producing messages 
     */
    op boolean extraValidate(EDiagnosticChain diagnostics, EMap<Object, Object>context) {
        return OmlValidator2.INSTANCE.run(this, diagnostics, context)
    }
    /*
     * Gets the ontology that defines this element
     */
    op Ontology getOntology() {
        var EObject current = this
        while (current !== null && !(current instanceof Ontology)) {
            current = current.eContainer()
        }
        return current as Ontology
    }
}

////////////////////////////////////////
//  Elements 
////////////////////////////////////////

/*
 * Annotation is an element that specifies additional non-semantic statements on an annotated element. 
 * An annotation is specified with an annotation property and a (literal or reference) value. When
 * no value is specified, it is interpreted as the `true` boolean literal.
 */
@Bikeshed(heading="Elements")
class Annotation extends Element {
    /*
     * The annotation property specified by this annotation
     */
    refers AnnotationProperty[1] property
    /*
     * A literal value specified by this annotation.
     */
    contains Literal[?] literalValue
    /*
     * A reference (to a member) value specified by this annotation
     */
    refers Member[?] referenceValue
    /*
     * The annotated element that owns this annotation
     */
    container IdentifiedElement[?] owningElement opposite ownedAnnotations
    /*
     * Gets the value of the annotation
     */
    op Element getValue() {
    	if (literalValue !== null)
    		literalValue
    	else if (referenceValue !== null)
    		referenceValue
    }
    /*
     * Gets the annotated element of the given annotation
     */
    op IdentifiedElement getAnnotatedElement() {
        if (owningElement instanceof Member) {
            return (owningElement as Member).resolve()
        }
        return owningElement
    }
}

/*
 * IdentifiedElement is an annotated element that is identified by an IRI and can own a set of Annotations.
 */
@Bikeshed(heading="Elements")
abstract class IdentifiedElement extends Element {
    /*
     * The set of annotations owned directly by this element
     */
    contains Annotation[*] ownedAnnotations opposite owningElement
    /*
     * Gets the IRI of this element 
     */ 
    op String getIri()
}

/*
 * Import is an element owned by an ontology to specify that it imports another ontology.
 * The imported ontology is specified by its IRI, and optionally a separator character and local prefix
 * if members of the imported ontology will also be referenced by the importing ontology
 */
@Bikeshed(heading="Elements")
class Import extends Element {
	/*
	 * The kind of this import
	 */
	ImportKind[1] kind
    /*
     * The namespace of the imported ontology
     */
    Namespace[1] namespace
    /*
     * The local prefix of the imported ontology's namespace
     */
    ID[?] prefix
    /*
     * The ontology that owns this import
     */
    container Ontology[1] owningOntology opposite ownedImports
    /*
     * Get the import's iri
     */
    op String getIri() {
    	if (namespace === null) {
    		return null
    	}
     	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
        	return namespace
       	} else {
       		return namespace.substring(0, i)
       	}
    }
    /*
     * Get the import's separator char
     */
    op SeparatorKind getSeparator() {
     	if (namespace === null) {
    		return null
    	}
    	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
       		return null
       	} else {
        	return SeparatorKind.get(namespace.substring(i, i+1))
       	}
    }
}

/*
 * Instance is an element that represents an instance of a classifier. It can specify a set of values for the
 * classifier's (direct or inherited) properties.
 */
@Bikeshed(heading="Instances")
abstract class Instance extends Element {
    /*
     * The property value assertions specified by this instance
     */
    contains PropertyValueAssertion[*] ownedPropertyValues opposite owningInstance
}

/*
 * Axiom is an annotated element that represents a statement about a term in a vocabulary.
 */
@Bikeshed(heading="Axioms")
abstract class Axiom extends Element {
}

/*
 * Assertion is an element that represents a statement about an instance in a description.
 */
@Bikeshed(heading="Assertions")
abstract class Assertion extends Element {
    /**
     * Gets the instance that is the subject of this assertion
     */
    op Instance getSubject()
    /**
     * Gets the instance that is the object of this assertion
     */
    op Element getObject()
}

/*
 * Predicate is an element that represents an ontology statement to match, when used in a rule's antecedent, 
 * or to infer, when used in a rule's consequent.
 */
@Bikeshed(heading="Rules")
abstract class Predicate extends Element {
    /*
     * The rule that specifies this predicate in its antecedent
     */
    container Rule[?] antecedentRule opposite antecedent
    /*
     * The rule that specifies this predicate in its consequent
     */
    container Rule[?] consequentRule opposite consequent
}

/*
 * Argument is an element that represents an argument to a predicate specified as a variable, a literal, or an instance
 */
@Bikeshed(heading="Rules")
class Argument extends Element {
    /*
     * An optional variable specified by this argument
     */
    ID[?] variable
    /*
     * An optional literal specified by this argument
     */
    contains Literal[?] literal
    /*
     * An optional instance specified by this argument
     */
    refers NamedInstance[?] instance
}

/*
 * Literal is an element that represents a specific literal value classified by a scalar.
 */
@Bikeshed(heading="Literals")
abstract class Literal extends Element {
	/*
     * Gets the value of the given literal
	 */
    op Object getValue()
    /*
     * Gets the string value of the given literal
     */
    op String getStringValue() {
        return if (getValue() !== null) getValue().toString() else ""
    }
    /*
     * Gets the lexical value of the given literal
     */
    op String getLexicalValue() {
        return getStringValue()   
    }
    /*
     * Gets the iri of the given literal's type
     */
    op String getTypeIri()
}

////////////////////////////////////////
//  Identified Elements 
////////////////////////////////////////

/*
 * Ontology is an identified element that represents a namespace for its members. The namespace is defined
 * by a globally unique namespace (an iri and a namespace separator that can be # or /) and can be abbreviated with a prefix. 
 * An ontology can import other ontologies, and can make statements about its own as well as imported members.
 */
@Bikeshed(heading="Elements")
abstract class Ontology extends IdentifiedElement {
    /*
     * The globally unique namespace of this ontology
     */
    Namespace[1] namespace
    /*
     * The prefix of this ontology's namespace
     */
    ID[1] prefix
    /*
     * The set of imports this ontology has to other ontologies
     */
    contains Import[*] ownedImports opposite owningOntology
    /*
     * Get the namespace's iri
     */
    op String getIri() {
    	if (namespace === null) {
    		return null
    	}
     	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
        	return namespace
       	} else {
       		return namespace.substring(0, i)
       	}
    }
    /*
     * Get the namespace's separator char
     */
    op SeparatorKind getSeparator() {
     	if (namespace === null) {
    		return null
    	}
    	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
       		return null
       	} else {
        	return SeparatorKind.get(namespace.substring(i, i+1))
       	}
    }
}

/*
 * Member is an identified element defined by an ontology. Its IRI is unique and derived by concatenating the globally
 * unique namespace of its ontology with its locally unique name (i.e., member.iri=ontology.namespace+member.name).
 */
@Bikeshed(heading="Elements")
abstract class Member extends IdentifiedElement {
    /*
     * A unique name for the member within its ontology
     */
    id ID[?] name
    
    /*
     * Gets the Ref of this member
     */
    op Member[?] getRef()
    /*
     * Determines if the member is a ref to another member
     */
    op boolean isRef() {
    	return getRef() !== null
    }
    /*
     * Determines if the member is a ref to another member
     */
    op Member[1] resolve() {
    	if (isRef()) {
    		return getRef()
    	}
    	return this
    }
    /*
     * Gets the IRI of this member (empty string if a proxy)
     */
    op String getIri() {
    	val m = resolve()
    	if (m.eIsProxy()) return (m as InternalEObject).eProxyURI().toString()
        val ontology = m.ontology
        val namespace = if (ontology !== null) ontology.namespace else SeparatorKind.HASH
        return namespace + if (m.name !== null) m.name else ''
    }
    /*
     * Gets the abbreviated IRI of this member (empty string if a proxy)
     */
    op String getAbbreviatedIri() {
     	val m = resolve()
    	if (m.eIsProxy()) return (m as InternalEObject).eProxyURI().toString()
        val ontology = m.ontology
        val prefix = if (ontology !== null) ontology.prefix  + ':' else ':'
        return prefix + if (m.name !== null) m.name else ''
    }
}

////////////////////////////////////////
//  Ontologies 
////////////////////////////////////////

/*
 * VocabularyBox is an ontology whose members are terms and rules.
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyBox extends Ontology {
}

/*
 * DescriptionBox is an ontology whose members are instances (of terms defined in vocabulary boxes)
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionBox extends Ontology {
}

////////////////////////////////////////
//  Vocabulary Boxes 
////////////////////////////////////////

/*
 * Vocabulary is a vocabulary box that allows making statements about its own terms and rules
 * or about others that are imported.
 */
@Bikeshed(heading="Vocabularies")
class Vocabulary extends VocabularyBox {
    /*
     * The set of statements contained by this vocabulary
     */
    contains VocabularyStatement[*] ownedStatements opposite owningVocabulary
}

/*
 * VocabularyBundle is a vocabulary box that allows importing other vocabulary boxes and flagging them
 * as disjoint from one another.
 */
@Bikeshed(heading="Vocabularies")
class VocabularyBundle extends VocabularyBox {
}

////////////////////////////////////////
//  Description Boxes 
////////////////////////////////////////

/*
 * Description is a description box that allows making statements about its own instances or about
 * others that are imported.
 */
@Bikeshed(heading="Descriptions")
class Description extends DescriptionBox {
    /*
     * The set of statements contained by this description
     */
    contains DescriptionStatement[*] ownedStatements opposite owningDescription
}

/*
 * DescriptionBundle is a description box that allows importing other description boxes and flagging them
 * as a set that is analyzed together for consistency and satisfiabilty.
 */
@Bikeshed(heading="Descriptions")
class DescriptionBundle extends DescriptionBox {
}

////////////////////////////////////////
//  Members 
////////////////////////////////////////

/*
 * Statement is a member that is owned by an ontology.  
 */
@Bikeshed(heading="Elements")
abstract class Statement extends Member {
}

/*
 * VocabularyMember is a member of a vocabulary.
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyMember extends Member {
}

/*
 * DescriptionMember is a member of a description.
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionMember extends Member {
}

////////////////////////////////////////
//  Statements
////////////////////////////////////////

/*
 * VocabularyStatement is a statement owned by a vocabulary.
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyStatement extends Statement, VocabularyMember {
    /*
     * The vocabulary that owns this statement
     */
    container Vocabulary[1] owningVocabulary opposite ownedStatements
}

/*
 * DescriptionStatement is a statement owned by a description.
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionStatement extends Statement, DescriptionMember {
    /*
     * The description that owns this statement
     */
    container Description[1] owningDescription opposite ownedStatements
}

////////////////////////////////////////
//  Vocabulary Members
////////////////////////////////////////

/*
 * Term is a member of a vocabulary that provides a particular semantic meaning when used in an assertion.
 */
@Bikeshed(heading="Vocabularies")
abstract class Term extends VocabularyMember {
}

/*
 * Rule is a member of a vocabulary that adds a new inference rule to the set supported natively by DL. A rule must specify a set of one or
 * more antecedent predicates that forms a conjunction that infers, when it holds, a set of one or more consequent predicates. Each
 * predicate in a rule may specify (one or two) variables. Those with the same name refer to the same variable, and hence must
 * be bound to the same value from the model for the rule to trigger during reasoning. A rule ref cannot respecify the
 * antecedent nor consequent of a rule.
 */
@Bikeshed(heading="Rules")
class Rule extends VocabularyStatement {
	/*
	 * A ref to another rule
	 */
	refers Rule ref
    /*
     * The set of predicates that form the antecedent of this rule
     */
    contains Predicate[*] antecedent opposite antecedentRule
    /*
     * The predicate that is the consequent of this rule
     */
    contains Predicate[*] consequent opposite consequentRule
}

/*
 * BuiltIn is a member of a vocabulary that represents a builtin function
 */
@Bikeshed(heading="Rules")
class BuiltIn extends VocabularyStatement {
	/*
	 * A ref to another builtin
	 */
	refers BuiltIn ref
}

////////////////////////////////////////
//  Terms 
////////////////////////////////////////

/*
 * SpecializableTerm is a term that can specialized in a taxonomy. It can have zero or more specializations.
 */
@Bikeshed(heading="Vocabularies")
abstract class SpecializableTerm extends Term, VocabularyStatement {
    /*
     * The specialization axioms owned by this term
     */
    contains SpecializationAxiom[*] ownedSpecializations opposite owningTerm
}

/*
 * Property is a term that relates an element to a value. It is the super type of all property types.
 */
@Bikeshed(heading="Properties")
abstract class Property extends Term {
}

////////////////////////////////////////
//  Specializable Terms
////////////////////////////////////////

/*
 * Type is a specializable term that classifies a set of instances or literals.
 */
@Bikeshed(heading="Types")
abstract class Type extends SpecializableTerm {
}

/*
 * RelationBase is a specializable term that is the superclass of a relation from a source entity to a target entity.
 * It can optionally name a reverse property whose domain is the target and whose range is the source.
 * It can also be characterized with several boolean flags that represent its DL semantics. 
 * Such flags apply conversely to the reverse property (if named). A relation base ref cannot respecify the source,
 * the target, nor the reverse relation. 
 */
@Bikeshed(heading="Properties")
abstract class RelationBase extends SpecializableTerm {
    /*
     * The entities that represent the sources of this relation base
     */
    refers Entity[*] sources
    /*
     * The entities that represent the targets of this relation base
     */
    refers Entity[*] targets
    /*
     * The optional reverse relation of this relation base
     */
    contains ReverseRelation[?] reverseRelation opposite relationBase
    /*
     * Whether this relation base is functional (i.e., {@code A -> B and A->C => B=C})
     */
    boolean functional
    /*
     * Whether this relation base is inverse functional (i.e., {@code B->A and C->A => B=C})
     */
    boolean inverseFunctional
    /*
     * Whether this relation base is symmetric (i.e., {@code A->B => B->A})
     */
    boolean symmetric
    /*
     * Whether this relation base is asymmetric (i.e., {@code A->B => !(B->A)})
     */
    boolean asymmetric
    /*
     * Whether this relation base is reflexive (i.e., {@code A => A->A})
     */
    boolean reflexive
    /*
     * Whether this relation base is irreflexive (i.e., {@code A => !(A->A)})
     */
    boolean irreflexive
    /*
     * Whether this relation base is transitive (i.e., {@code A->B and B->C => A->C})
     */
    boolean transitive
}

/*
 * SpecializableProperty is a property that can be specialized.
 */
@Bikeshed(heading="Properties")
abstract class SpecializableProperty extends SpecializableTerm, Property {
    /*
     * The set of property equivalence axioms of this property
     */
    contains PropertyEquivalenceAxiom[*] ownedEquivalences opposite owningProperty
}

////////////////////////////////////////
//  Types
////////////////////////////////////////

/*
 * Classifier is a type that classifies a set of instances and characterizes them with properties
 * (i.e., becomes a domain of these properties). It also inherits properties in the domain of its specialized 
 * types. In addition, it can specify constraints on (direct or inherited) properties in its domain.
 */
@Bikeshed(heading="Types")
abstract class Classifier extends Type {
    /*
     * The set of property restriction axioms of this classifier
     */
    contains PropertyRestrictionAxiom[*] ownedPropertyRestrictions opposite owningClassifier
    /*
     * The set of classifier equivalence axioms of this classifier
     */
    contains ClassifierEquivalenceAxiom[*] ownedEquivalences opposite owningClassifier
}

/*
 * Scalar is a primitive type that represents a set of literals. Some scalars are considered standard (enumerated below).
 *  
 * A non-standard scalar may specialize a standard scalar (in which case it is the only one), and optionally specify facets (restrictions) on it. 
 * The kind of restrictions allowed depend on the standard super scalar as detailed below.
 * 
 * A non-standard scalar may also specialize (one or more) non-standard scalars, in which case no facets should be specified) and the scalar is
 * considered semantically equivalent to those super scalars. 
 * 
 * The standard scalars (along with their supported facets):
 * 
 * Numeric scalars (facets: minInclusive, maxInclusive, minExclusive, maxExclusive, literals):
 * owl:real
 * owl:rational
 * xsd:decimal
 * xsd:integer
 * xsd:nonNegativeInteger
 * xsd:nonPositiveInteger
 * xsd:positiveInteger
 * xsd:negativeInteger
 * xsd:long
 * xsd:int
 * xsd:short
 * xsd:byte
 * xsd:unsignedLong
 * xsd:unsignedInt
 * xsd:unsignedShort
 * xsd:unsignedByte
 * xsd:double
 * xsd:float 
 * 
 * Time scalars (facets: minInclusive, maxInclusive, minExclusive, maxExclusive, literals):
 * xsd:dateTime
 * xsd:dateTimeStamp
 * 
 * Plain scalars (facets: length, minLength, maxLength, pattern, language, literals):
 * rdf:PlainLiteral

 * String scalars (facets: length, minLength, maxLength, pattern, literals)
 * xsd:string,
 * xsd:normalizedString,
 * xsd:token,
 * xsd:language,
 * xsd:Name,
 * xsd:NCName,
 * xsd:NMTOKEN
 * xsd:anyURI
 * 
 * Boolean scalars (literals):
 * xsd:boolean
 * 
 * Binary scalars (facets: length, minLength, maxLength, literals):
 * xsd:hexBinary
 * xsd:base64Binary
 * 
 * XML scalars (literals):
 * rdf:XMLLiteral
 */
@Bikeshed(heading="Types")
class Scalar extends Type {
	/*
	 * A ref to another faceted scalar
	 */
	refers Scalar ref
    /*
     * The exact length of the literals of this scalar
     */
    UnsignedInteger[?] length
    /*
     * The minimum length of the literals of this scalar
     */
    UnsignedInteger[?] minLength
    /*
     * The maximum length of the literals of this scalar
     */
    UnsignedInteger[?] maxLength
    /*
     * The pattern that the literals of this scalar conforms to
     */
    String[?] pattern
    /*
     * The language range that the literals of this scalar belong to 
     * (based on http://www.rfc-editor.org/rfc/bcp/bcp47.txt)
     */
    String[?] language
    /*
     * The minimum inclusive value of numeric literals of this scalar
     */
    contains Literal[?] minInclusive
    /*
     * The minimum exclusive value of numeric literals of this scalar
     */
    contains Literal[?] minExclusive
    /*
     * The maximum inclusive value of numeric literals of this scalar
     */
    contains Literal[?] maxInclusive
    /*
     * The maximum exclusive value of numeric literals of this scalar
     */
    contains Literal[?] maxExclusive
	/*
	 * An enumeration of literals of this scalar
	 */
	contains LiteralEnumerationAxiom[?] ownedEnumeration opposite owningScalar
}

////////////////////////////////////////
//  Classifiers
////////////////////////////////////////

/*
 * Entity is a classifier whose instances are named and can be interrelated. It can also additionally specify key axioms
 * that define how instances of the entity are unique.
 */
@Bikeshed(heading="Types")
abstract class Entity extends Classifier {
    /*
     * The unique keys of this entity
     */
    contains KeyAxiom[*] ownedKeys opposite owningEntity
}

/*
 * Structure is a characterizable type that represents a structured datatype whose instances are anonymous and assignable as
 * values to structured properties.
 */
@Bikeshed(heading="Types")
class Structure extends Classifier {
	/*
	 * A ref to another structure
	 */
	refers Structure ref
}

////////////////////////////////////////
//  Entities
////////////////////////////////////////

/*
 * Aspect is an entity that represents a concern that cuts across multiple entities. An aspect can only specialize other aspects.
 */
@Bikeshed(heading="Types")
class Aspect extends Entity {
	/*
	 * A ref to another aspect
	 */
	refers Aspect ref
}

/*
 * Concept is a concrete entity that classifies a set of concept instances. It can also specialize other concepts and/or aspects.
 */
@Bikeshed(heading="Types")
class Concept extends Entity {
	/*
	 * A ref to another concept
	 */
	refers Concept ref
	/*
	 * An enumeration of instances of this concept
	 */
	contains InstanceEnumerationAxiom[?] ownedEnumeration opposite owningConcept
}

/*
 * RelationEntity is an entity that represents a reified relation from a source entity to a target entity. 
 * It can optionally name a forward property whose domain is the source and whose range is the target.
 * If both are named, such forward property becomes the inverse of the entity's reverse property. 
 * If not, then a default forward property with the name 'has<Relation>Forward' is assumed. A relation entity ref
 * cannot respecify a forward relation.
 */
@Bikeshed(heading="Types")
class RelationEntity extends Entity, RelationBase {
	/*
	 * A ref to another relation entity
	 */
	refers RelationEntity ref
    /*
     * The optional forward relation of this relation entity
     */
    contains ForwardRelation[?] forwardRelation opposite relationEntity
}

////////////////////////////////////////
//  Properties
////////////////////////////////////////

/*
 * AnnotationProperty is a specializable property with no DL semantics that relates an annotated element to a literal value.
 */
@Bikeshed(heading="Properties")
class AnnotationProperty extends SpecializableProperty {
	/*
	 * A ref to another annotation property
	 */
	refers AnnotationProperty ref
}

/*
 * SemanticProperty is a property with DL semantics that relates a classifier acting as its
 * domain to a type acting as its range.
 */
@Bikeshed(heading="Properties")
abstract class SemanticProperty extends Property {
    /*
     * Determines if this property is functional (has a max of one value per instance) 
     */
    op boolean isFunctional()
    /*
     * Gets the domains of this property
     */
    op Classifier[] getDomainList()
    /*
     * Gets the ranges of this property
     */
    op Type[] getRangeList()
}

////////////////////////////////////////
//  Semantic Properties
////////////////////////////////////////

/*
 * ScalarProperty is a semantic property whose range is a scalar. It can specialize other scalar properties.
 * It can also be flagged as a key property (among possibly several) that specifies the unique id of its domain.
 * A scalar property ref cannot respecify the domain nor the range.
 */
@Bikeshed(heading="Properties")
class ScalarProperty extends SemanticProperty, SpecializableProperty {
	/*
	 * A ref to another scalar property
	 */
	refers ScalarProperty ref
    /*
     * Whether this property is functional (has a max of one value per instance) 
     */
    boolean functional
    /*
     * The classifier that is the domain of this property
     */
    refers Classifier[*] domains
    /*
     * The scalar that is the range of this property
     */
    refers Scalar[*] ranges

    op Classifier[] getDomainList() {
    	domains
    }
    op Type[] getRangeList() {
    	new BasicEList(ranges)
    }
}

/*
 * StructuredProperty is a semantic property whose range is a structure. It can specialize other structured properties.
 * A structured property ref cannot respecify the domain nor the range.
 */
@Bikeshed(heading="Properties")
class StructuredProperty extends SemanticProperty, SpecializableProperty {
	/*
	 * A ref to another structured property
	 */
	refers StructuredProperty ref
    /*
     * Whether this property is functional (has a max of one value per instance) 
     */
    boolean functional
    /*
     * The classifiers that are the domains of this property
     */
    refers Classifier[*] domains
    /*
     * The structures that are the range of this property
     */
    refers Structure[*] ranges

    op Classifier[] getDomainList() {
    	domains
    }
    op Type[] getRangeList() {
    	new BasicEList(ranges)
    }
}

/*
 * Relation is a semantic property whose domain is an entity and whose range is also an entity.
 * It can be characterized by DL flags and can have an inverse relation.
 */
@Bikeshed(heading="Properties")
abstract class Relation extends SemanticProperty {
    /*
     * Gets whether this relation is inverse functional (i.e., {@code B->A and C->A => B=C})
     */
    op boolean isInverseFunctional()
    /*
     * Gets whether this relation is symmetric (i.e., {@code A->B => B->A})
     */
    op boolean isSymmetric()
    /*
     * Gets whether this relation is asymmetric (i.e., {@code A->B => !(B->A)})
     */
    op boolean isAsymmetric()
    /*
     * Gets whether this relation is reflexive (i.e., {@code A => A->A})
     */
    op boolean isReflexive()
    /*
     * Gets whether this relation is irreflexive (i.e., {@code A => !(A->A)})
     */
    op boolean isIrreflexive()
    /*
     * Gets whether this relation is transitive (i.e., {@code A->B and B->C => A->C})
     */
    op boolean isTransitive()
    /*
     * Gets the domain of this relation
     */
    op Entity[*] getDomains()
    /*
     * Gets the range of the relation
     */
    op Entity[*] getRanges()
    /*
     * Gets the inverse of this relation
     */
    op Relation[?] getInverse()

    op Classifier[] getDomainList() {
    	new BasicEList(getDomains())
    }
    op Type[] getRangeList() {
    	new BasicEList(getRanges())
    }
}

////////////////////////////////////////
//  Relations
////////////////////////////////////////

/*
 * ForwardRelation is a relation that is defined by a relation entity. Its domain is the source of the relation
 * entity, and its range is the target of the relation entity. The DL semantics of a forward property are the same as those 
 * of its relation entity.
 */
@Bikeshed(heading="Properties")
class ForwardRelation extends Relation {
    /*
     * The relation entity that owns this forward property
     */
    container RelationEntity[1] relationEntity opposite forwardRelation
    
    op Member getRef() {
    	null
    }
    op boolean isFunctional() {
        relationEntity.functional
	}
    op boolean isInverseFunctional() {
        relationEntity.inverseFunctional
    }
    op boolean isSymmetric() {
        relationEntity.symmetric
    }
    op boolean isAsymmetric() {
        relationEntity.asymmetric
    }
    op boolean isReflexive() {
        relationEntity.reflexive
    }
    op boolean isIrreflexive() {
        relationEntity.irreflexive
    }
    op boolean isTransitive() {
        relationEntity.transitive
    }
    op Entity[*] getDomains() {
		relationEntity.sources
    }
    op Entity[*] getRanges() {
		relationEntity.targets
    }
    op Relation getInverse() {
		relationEntity.reverseRelation
    }
}

/*
 * ReverseRelation is a relation that is defined by a relation base and represents its inverse relation. Its domain
 * is the target of the relation base, and its range is the source of the relation base. The DL semantics of a reverse property are 
 * derived from those of its relation.
 */
@Bikeshed(heading="Properties")
class ReverseRelation extends Relation {
    /*
     * The relation that owns this reverse property
     */
    container RelationBase[1] relationBase opposite reverseRelation
    
    op Member getRef() {
    	null
    }
    op boolean isFunctional() {
        relationBase.inverseFunctional
	}
    op boolean isInverseFunctional() {
        relationBase.inverseFunctional
    }
    op boolean isSymmetric() {
        relationBase.symmetric
    }
    op boolean isAsymmetric() {
        relationBase.asymmetric
    }
    op boolean isReflexive() {
        relationBase.reflexive
    }
    op boolean isIrreflexive() {
       relationBase.irreflexive
    }
    op boolean isTransitive() {
        relationBase.transitive
    }
    op Entity[*] getDomains() {
        relationBase.targets
    }
    op Entity[*] getRanges() {
        relationBase.sources
    }
    op Relation getInverse() {
        if (relationBase instanceof RelationEntity)
            (relationBase as RelationEntity).forwardRelation
        else if (relationBase instanceof Relation)
        	relationBase as Relation
    }
}

/*
 * UnreifiedRelation is a simple relation from a source entity to a target entity. 
 */
@Bikeshed(heading="Properties")
class UnreifiedRelation extends Relation, RelationBase, SpecializableProperty {
	/*
	 * A ref to another relation
	 */
	refers Relation ref

    op Entity[*] getDomains() {
        sources
    }
    op Entity[] getRanges() {
    	targets
    }
    op Relation getInverse() {
		reverseRelation
    }
}

////////////////////////////////////////
//  Description Members
////////////////////////////////////////

/*
 * NamedInstance is an instance that is a member of a description.
 */
@Bikeshed(heading="Instances")
abstract class NamedInstance extends DescriptionStatement, Instance {
    /*
     * The types of this instance
     */
    contains TypeAssertion[*] ownedTypes opposite owningInstance
}

////////////////////////////////////////
//  Named Instances
////////////////////////////////////////

/*
 * ConceptInstance is a named instance that can be typed by concepts.
 */
@Bikeshed(heading="Instances")
class ConceptInstance extends NamedInstance {
	/*
	 * A ref to another concept instance
	 */
	refers ConceptInstance ref
}

/*
 * RelationInstance is a named instance that can be typed by relation entities and represents a relation from one or 
 * more named instances (as sources) to one or more named instances (as targets).
 */
@Bikeshed(heading="Instances")
class RelationInstance extends NamedInstance {
	/*
	 * A ref to another relation instance
	 */
	refers RelationInstance ref
    /*
     * The named instances that are the sources of this relation instance
     */
    refers NamedInstance[*] sources
    /*
     * The named instances that are the targets of this relation instance
     */
    refers NamedInstance[*] targets
}

////////////////////////////////////////
//  Instances
////////////////////////////////////////

/*
 * StructureInstance is an instance that can be typed by a structure. It is anonymous and gets assigned as a value of a structured property
 * either in a property value restriction axiom or a property value assertion
 */
@Bikeshed(heading="Instances")
class StructureInstance extends Instance {
    /*
     * The type of this instance
     */
    refers Structure[1] ^type
    /*
     * The property value restriction axiom that assigns this instance as a restricted value
     */
    container PropertyValueRestrictionAxiom[?] owningAxiom opposite structureInstanceValue
    /*
     * The property value assertion that assigns this instance as a value
     */
    container PropertyValueAssertion[?] owningAssertion opposite structureInstanceValue
}

////////////////////////////////////////
//  Axioms
////////////////////////////////////////

/*
 * KeyAxiom is an axiom that specifies that a set of properties form a unique key for an entity. This means that all 
 * instances of that entity must have unique values for those keys.
 */
@Bikeshed(heading="Axioms")
class KeyAxiom extends Axiom {
    /*
     * The set of key properties specified by this axiom
     */
    refers Property[+] properties
    /*
     * The owning entity specified by this axiom
     */
    container Entity[?] owningEntity opposite ownedKeys
    /*
     * Gets the entity that defines the given key axiom
     */
    op Entity getKeyedEntity() {
    	return owningEntity.resolve() as Entity
    }

}

/*
 * SpecializationAxiom is an axiom specified on a specializing term that states that one specializable term specializes another.
 */
@Bikeshed(heading="Axioms")
class SpecializationAxiom extends Axiom {
    /*
     * The super term specified by this axiom
     */
    refers Term[1] superTerm
    /*
     * The owning term specified by this axiom
     */
    container SpecializableTerm[?] owningTerm opposite ownedSpecializations
    /*
     * Gets the sub (specific) term of the given specialization axiom
     */
    op Term getSubTerm() {
    	return owningTerm.resolve() as Term
    }
}

/*
 * InstanceEnumerationAxiom is an axiom specified on a concept that states that it classifies an enumerated set of instances.
 */
@Bikeshed(heading="Axioms")
class InstanceEnumerationAxiom extends Axiom {
	/*
	 * The set of enumerated instances specified by this axiom
	 */
	refers ConceptInstance[+] instances
    /*
     * The owning concept specified by this axiom
     */
    container Concept[?] owningConcept opposite ownedEnumeration
    /*
     * Gets the concept that defines the given enumeration axiom
     */
    op Concept getEnumeratedConcept() {
    	return owningConcept.resolve() as Concept
    }
}

/*
 * PropertyRestrictionAxiom is an axiom specified on the classifier that places some restriction on the value of a semantic property in the context of
 * a restricting classifier domain.
 */
@Bikeshed(heading="Axioms")
abstract class PropertyRestrictionAxiom extends Axiom {
    /*
     * The restricted property specified by this axiom
     */
    refers SemanticProperty[1] property
    /*
     * The owning classifier specified by this axiom
     */
    container Classifier[?] owningClassifier opposite ownedPropertyRestrictions
    /*
     * The owning classifier equivalence axiom specified by this axiom
     */
    container ClassifierEquivalenceAxiom[?] owningAxiom opposite ownedPropertyRestrictions
    /*
     * Gets the restricting domain of the given property restriction axiom
     */
    op Classifier getRestrictingDomain() {
    	if (owningAxiom !== null) {
    		return owningAxiom.subClassifier
   		}
    	return owningClassifier.resolve() as Classifier
    }
    
}

/*
 * LiteralEnumerationAxiom is an axiom specified on a scalar that states that it classifies an enumerated set of literals.
 */
@Bikeshed(heading="Axioms")
class LiteralEnumerationAxiom extends Axiom {
	/*
	 * The set of enumerated literals specified by this axiom
	 */
	contains Literal[+] literals
    /*
     * The owning scalar specified by this axiom
     */
    container Scalar[?] owningScalar opposite ownedEnumeration
    /*
     * Gets the scalar that defines the given enumeration axiom
     */
    op Scalar getEnumeratedScalar() {
    	return owningScalar.resolve() as Scalar
    }
}

/*
 * ClassifierEquivalenceAxiom is an axiom specified on a classifier that states that it is equivalent to the intersection of named classifiers
 * and property restrictions. This axiom implies that the named classifiers are super types of the subject classifier. It also implies
 * that when an instance is classified by this intersection, then it follows that it is also classified by the subject classifier. 
 * Conversely, when an instance is classified by the subject classifier, then it follows that it is also classified by the intersection.
 * In other words, this axiom enables bi-directional (or two-way) inferencing.
 */
@Bikeshed(heading="Axioms")
class ClassifierEquivalenceAxiom extends Axiom {
    /*
     * The super classifiers specified by this axiom
     */
    refers Classifier[*] superClassifiers
    /*
     * The property restrictions specified by this axiom
     */
    contains PropertyRestrictionAxiom[*] ownedPropertyRestrictions opposite owningAxiom
    /*
     * The owning classifier specified by this axiom
     */
    container Classifier[?] owningClassifier opposite ownedEquivalences
    /*
     * Gets the sub classifier of this axiom
     */
    op Classifier getSubClassifier() {
    	return owningClassifier.resolve() as Classifier
    }
}

/*
 * PropertyEquivalenceAxiom is an axiom specified on a proeprty that states that it is equivalent to another property. This axiom implies that
 * the equivalent properties are super properties of the subject property (and vice versa).
 */
@Bikeshed(heading="Axioms")
class PropertyEquivalenceAxiom extends Axiom {
    /*
     * The super property specified by this axiom
     */
    refers Property[1] superProperty
    /*
     * The owning property specified by this axiom
     */
    container SpecializableProperty[?] owningProperty opposite ownedEquivalences
    /*
     * Gets the sub property of this axiom
     */
    op Property getSubProperty() {
    	return owningProperty.resolve() as Property
    }
}


////////////////////////////////////////
//  Property Restriction Axioms
////////////////////////////////////////

/*
 * PropertyRangeRestrictionAxiom is a property restriction axiom that restricts the range of a property to
 * a type that specializes the original range. This restrictions may apply to all or to some values of the property
 * that have the restricting classifier as a domain.
 */
@Bikeshed(heading="Axioms")
class PropertyRangeRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * The range restriction kind specified by this axiom (default is all)
     */
    RangeRestrictionKind[1] kind = "all" 
    /*
     * The restricted range specified by this axiom
     */
    refers Type[1] range
}

/*
 * PropertyCardinalityRestrictionAxiom is a property restriction axiom that restricts the cardinality of a property
 * to an exact value, a minimum value or a maximum value. This restrictions can apply either to all values of the property 
 * in the restricting classifier, or only to those values classified by a specific subtype of the range.
 */
@Bikeshed(heading="Axioms")
class PropertyCardinalityRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * The kind of cardinality restriction specified by this axiom (default is exactly)
     */
    CardinalityRestrictionKind[1] kind = "exactly"
    /*
     * The value of the cardinality specified by this axiom (default is 1)
     */
    UnsignedInt[1] cardinality = "1"
    /*
     * The optional restricted range specified by this axiom
     */
    refers Type[?] range
}

/*
 * PropertyValueRestrictionAxiom is a property restriction axiom that restricts a property in a given domain to a specific
 * value. The value is either a literal value in the case of a scalar property, a contained (structure) instance value in the case of
 * a structured property, or a referenced (named) instance value in the case of a relation.
 */
@Bikeshed(heading="Axioms")
class PropertyValueRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * A restricted literal value (of a scalar property) 
     */
    contains Literal[?] literalValue
    /*
     * A restricted structure instance value (of a structured property) 
     */
    contains StructureInstance[?] structureInstanceValue opposite owningAxiom
    /*
     * A restricted named instance value (of a relation) 
     */
    refers NamedInstance[?] namedInstanceValue
    /*
     * Gets the restricted value
     */
    op Element getValue() {
    	if (property instanceof ScalarProperty)
    		literalValue
    	else if (property instanceof StructuredProperty)
    		structureInstanceValue
    	else if (property instanceof Relation)
    		namedInstanceValue
    }
}

////////////////////////////////////////
//  Assertions
////////////////////////////////////////

/*
 * TypeAssertion is an assertion that specifies a type for an instance 
 */
@Bikeshed(heading="Assertions")
class TypeAssertion extends Assertion {
    /*
     * The type of the instance owning this assertion
     */
    refers Entity[1] ^type
    /*
     * The instance that owns this assertion
     */
    container NamedInstance[?] owningInstance opposite ownedTypes

    op NamedInstance getSubject() {
    	return owningInstance.resolve() as NamedInstance
    }
    op Element getObject() {
    	return ^type
    }
}

/*
 * PropertyValueAssertion is an assertion that specifies a value for a property on an instance. The value is either a literal value 
 * in the case of a scalar property, a contained (structure) instance value in the case of a structured property, or a referenced 
 * (named) instance value in the case of a relation.
 */
@Bikeshed(heading="Assertions")
class PropertyValueAssertion extends Assertion {
    /*
     * The property referenced by this assertion
     */
    refers SemanticProperty[1] property
    /*
     * An asserted literal value of a scalar property 
     */
    contains Literal[?] literalValue
    /*
     * An asserted structure instance value of a structured property 
     */
    contains StructureInstance[?] structureInstanceValue opposite owningAssertion
    /*
     * An asserted named instance value of a relation 
     */
    refers NamedInstance[?] namedInstanceValue
    /*
     * The instance that this property value assertion is about
     */
    container Instance[?] owningInstance opposite ownedPropertyValues
    /*
     * Gets the asserted value
     */
    op Element getValue() {
    	if (property instanceof ScalarProperty)
    		literalValue
    	else if (property instanceof StructuredProperty)
    		structureInstanceValue
    	else if (property instanceof Relation)
    		namedInstanceValue
    }

    op Instance getSubject() {
        if (owningInstance instanceof NamedInstance) {
            return (owningInstance as NamedInstance).resolve() as NamedInstance
        }
        return owningInstance
    }
    op Element getObject() {
    	return getValue()
    }
}

////////////////////////////////////////
//  Predicates
////////////////////////////////////////

/*
 * UnaryPredicate is a predicate that has one argument
 */
@Bikeshed(heading="Rules")
abstract class UnaryPredicate extends Predicate {
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument
}

/*
 * BinaryPredicate is a predicate that has two arguments: argument1 and argument2
 */
@Bikeshed(heading="Rules")
abstract class BinaryPredicate extends Predicate {
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument1
    /*
     * An argument of the predicate
     */
    contains Argument[1] argument2
}

/*
 * BuiltInPredicate is a predicate that has two arguments: argument1 and argument2
 */
@Bikeshed(heading="Rules")
class BuiltInPredicate extends Predicate {
    /*
     * The called builtin
     */
    refers BuiltIn[1] builtIn
    /*
     * An argument of the predicate
     */
    contains Argument[+] arguments
}

////////////////////////////////////////
//  Unary Predicates
////////////////////////////////////////

/*
 * TypePredicate is a unary predicate whose argument is bound to a value typed by a given type.
 */
@Bikeshed(heading="Rules")
class TypePredicate extends UnaryPredicate {
    /*
     * The type of a value
     */
    refers Type[1] ^type
}

/*
 * RelationEntityPredicate is a unary and binary predicate that holds when its argument is bound to an instance typed by the given relation 
 * entity, its argument1 is bound to the source of that relation instance and its argument2 is bound to the target of that relation instance
 * .
 */
@Bikeshed(heading="Rules")
class RelationEntityPredicate extends UnaryPredicate, BinaryPredicate {
    /*
     * The type of a relation instance
     */
    refers RelationEntity[1] ^type
}

////////////////////////////////////////
//  Binary Predicates
////////////////////////////////////////

/*
 * PropertyPredicate is a binary predicate that holds when its argument1 is bound to an instance and its argument2 is bound to a
 * a value of a given property on that instance.
 */
@Bikeshed(heading="Rules")
class PropertyPredicate extends BinaryPredicate {
    /*
     * The property of an instance 
     */
    refers Property[1] property
}

/*
 * SameAsPredicate is a binary predicate that holds when its two arguments are bound to the same instance
 */
@Bikeshed(heading="Rules")
class SameAsPredicate extends BinaryPredicate {
}

/*
 * DifferentFromPredicate is a binary predicate that holds when its two arguments are bound to different instances
 */
@Bikeshed(heading="Rules")
class DifferentFromPredicate extends BinaryPredicate {
}


////////////////////////////////////////
//  Literals
////////////////////////////////////////

/*
 * QuotedLiteral is a literal that specifies its lexical value as a quoted string along with a language tag, a scalar type, or neither.
 */
@Bikeshed(heading="Literals")
class QuotedLiteral extends Literal  {
    /*
     * The value of this literal represented as a string
     */
    String[1] value
    /*
     * The langTag of this literal
     */
    String[?] langTag
    /*
     * The scalar that is the type of this literal
     */
    refers Scalar[?] ^type

    op String getLexicalValue() {
        return '"'+value+'"' + if (getLangTag !== null) "$"+getLangTag else if (getType() !== null) "^^"+ getType().getAbbreviatedIri() else ""
    }
    op String getTypeIri() {
    	return if (^type !== null) ^type.getIri() else OmlConstants.XSD_NS+"string" 
    }
}

/*
 * IntegerLiteral is a literal that represents a 32-bit integer value
 */
@Bikeshed(heading="Literals")
class IntegerLiteral extends Literal  {
    /*
     * The int value of this literal
     */
    Integer value = "0"

    op String getTypeIri() {
    	return OmlConstants.XSD_NS+"integer" 
    }
}

/*
 * DecimalLiteral is a literal that represents an arbitrary precision decimal value
 */
@Bikeshed(heading="Literals")
class DecimalLiteral extends Literal  {
    /*
     * The decimal value of this literal
     */
    Decimal[1] value = "0.0"

    op String getTypeIri() {
    	return OmlConstants.XSD_NS+"decimal" 
    }
}

/*
 * DoubleLiteral is a literal that represents a 64-bit double precision floating point value
 */
@Bikeshed(heading="Literals")
class DoubleLiteral extends Literal  {
    /*
     * The double value of this literal
     */
    Double value = "0.0"

    op String getTypeIri() {
    	return OmlConstants.XSD_NS+"double" 
    }
}

/*
 * BooleanLiteral is a literal that represents the boolean values true/false
 */
@Bikeshed(heading="Literals")
class BooleanLiteral extends Literal {
    /*
     * The boolean value of this literal
     */
    Boolean value = "false"
    
    op boolean isValue() {
    	return getValue().booleanValue
    }

    op String getTypeIri() {
    	return OmlConstants.XSD_NS+"boolean" 
    }
}

////////////////////////////////////////
//  Enumerations
////////////////////////////////////////

/*
 * SeparatorKind is an enumeration that specifies the separator character of an ontology's namespace. It can either
 * be only of two values: a hash '#' or a slash '/'.
 */
@Bikeshed(heading="Enumerations")
enum SeparatorKind {
    hash as '#' = 0
    slash as '/' = 1
}

/*
 * RangeRestrictionKind is an enumeration that specifies the scope of a range restriction on a property
 */
@Bikeshed(heading="Enumerations")
enum RangeRestrictionKind {
    /*
     * All values are restricted to the range
     */
    all = 0
    /*
     * Some values are restricted to the range
     */
    some = 1
}

/*
 * CardinalityRestrictionKind is an enumeration that specifies the kind of cardinality restriction on a property
 */
@Bikeshed(heading="Enumerations")
enum CardinalityRestrictionKind {
    /*
     * The cardinality must match this
     */
    exactly = 0
    /*
     * The cardinality is at least this
     */
    min = 1
    /*
     * The cardinality is at most this
     */
    max = 2
}

/*
 * ImportKind is an enumeration that specifies the kind of import
 */
@Bikeshed(heading="Enumerations")
enum ImportKind {
    /*
     * Extension is an import that allows an ontology to extend another of the same type. 
     */
    ^extension as "extends" = 0
    /*
 	 * Usage is an import that allows an ontology to use another of a different box type.
 	 */
    usage as "uses" = 1
    /*
	 * Inclusion is an import that allows a bundle ontology to include a non-bundle ontology of the same box type. 
     */
    inclusion as "includes" = 2
}

////////////////////////////////////////
//  Primitive Types
////////////////////////////////////////

@ExtendedMetaData(minInclusive="0", maxInclusive="4294967295")
type UnsignedInt wraps long

@ExtendedMetaData(minInclusive="0", maxInclusive="4294967295")
type UnsignedInteger wraps Long

@ExtendedMetaData(baseType="http://www.w3.org/2001/XMLSchema#decimal")
type Decimal wraps BigDecimal

@ExtendedMetaData(pattern="[a-zA-Z0-9_]([a-zA-Z0-9_\\-.$])*")
type ID wraps String

@ExtendedMetaData(pattern="([^\\s#])*(#|/)", minLength="2")
type Namespace wraps String
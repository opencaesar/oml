/*
 * This Ecore package specifies the syntax (metamodel) of the Ontological Modeling Language. OML models are instances of 
 * this metamodel and can be manipulated using its API.     
 */
@Ecore(
    nsPrefix="oml",
    nsURI="http://opencaesar.io/oml"
)
@GenModel(
    copyrightText="\nCopyright 2019-2022 California Institute of Technology (\"Caltech\").\nU.S. Government sponsorship acknowledged.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n",
    modelDirectory="/io.opencaesar.oml/src-gen",
    editDirectory="/io.opencaesar.oml.edit/src-gen",
    //editorDirectory="/io.opencaesar.oml.editor/src-gen",
    importerID="org.eclipse.xsd.ecore.importer",
    complianceLevel="11.0"
)
@BikeshedHeadings(
    Elements="",
    Literals="",
    Ontologies="",
    Vocabularies="",
    Types="",
    Features="",
    Rules="",
    Axioms="",
    Descriptions="",
    Instances="",
    Assertions="",
    References=""
)
@Bikeshed(heading="Abstract-Syntax")
package io.opencaesar.oml

import io.opencaesar.oml.util.OmlValidator2
import java.math.BigDecimal
import org.eclipse.emf.ecore.EDiagnosticChain
import org.eclipse.emf.ecore.EMap
import org.eclipse.emf.ecore.EObject

annotation "https://tabatkins.github.io/bikeshed" as Bikeshed
annotation "https://tabatkins.github.io/bikeshed/headings" as BikeshedHeadings

////////////////////////////////////////
//  Root 
////////////////////////////////////////

/*
 * Element is the most general type in the OML metamodel. All objects in an OML model are elements.
 */
@Bikeshed(heading="Elements")
abstract class Element {
    /*
     * Validates this element by extra validation rules
     * @param diagnostics validation error diagnostics
     * @param context object-to-object map used in producing messages 
     */
    op boolean extraValidate(EDiagnosticChain diagnostics, EMap<Object, Object>context) {
        return OmlValidator2.INSTANCE.run(this, diagnostics, context)
    }
    /*
     * Gets the ontology that defines this element
     */
    op Ontology getOntology() {
        var EObject current = this;
        while (current !== null && !(current instanceof Ontology)) {
            current = current.eContainer()
        }
        return current as Ontology
    }
}

////////////////////////////////////////
//  Elements 
////////////////////////////////////////

/*
 * Annotation is an element that specifies additional non-semantic information on an annotated element. It can also be
 * specified on a reference to an ontology member, in which case it is interpreted as if it was specified on the
 * member itself. An annotation is specified with an annotation property and an optional literal or reference value. When
 * no value is specified, it is interpreted as a boolean `true` literal.
 */
@Bikeshed(heading="Elements")
class Annotation extends Element {
    /*
     * The annotation property specified by this annotation
     */
    refers AnnotationProperty[1] property
    /*
     * The literal value specified by this annotation.
     */
    contains Literal[?] value
    /*
     * The reference value (to a member) specified by this annotation
     */
    refers Member[?] referenceValue 
    /*
     * The annotated element that owns this annotation
     */
    container IdentifiedElement[?] owningElement opposite ownedAnnotations
    /*
     * The reference that owns this annotation
     */
    container Reference[?] owningReference opposite ownedAnnotations
}

/*
 * IdentifiedElement is an annotated element that is identified by an IRI and can own a set of Annotations.
 */
@Bikeshed(heading="Elements")
abstract class IdentifiedElement extends Element {
    /*
     * Gets the IRI of this element 
     */ 
    op String getIri()
    /*
     * The set of annotations owned directly by this element
     */
    contains Annotation[*] ownedAnnotations opposite owningElement
}

/*
 * Import is an element owned by an ontology to specify that it imports another ontology.
 * The imported ontology is specified by its IRI, and optionally a separator character and local prefix
 * if members of the imported ontology will also be referenced by the importing ontology
 */
@Bikeshed(heading="Elements")
abstract class Import extends Element {
    /*
     * The namespace of the imported ontology
     */
    Namespace[1] namespace
    /*
     * The local prefix of the imported ontology's namespace
     */
    ID[?] prefix
    /*
     * The ontology that owns this import
     */
    container Ontology[1] owningOntology opposite ownedImports
    /*
     * Get the import's iri
     */
    op String getIri() {
    	if (namespace === null) {
    		return null
    	}
     	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
        	return namespace
       	} else {
       		return namespace.substring(0, i)
       	}
    }
    /*
     * Get the import's separator char
     */
    op SeparatorKind getSeparator() {
     	if (namespace === null) {
    		return null
    	}
    	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
       		return null
       	} else {
        	return SeparatorKind.get(namespace.substring(i, i+1))
       	}
    }
}

/*
 * Instance is an element that represents an instance of a classifier. It can specify a set of values for the
 * classifier's (direct or inherited) properties.
 */
@Bikeshed(heading="Instances")
abstract class Instance extends Element {
    /*
     * The property value assertions specified by this instance
     */
    contains PropertyValueAssertion[*] ownedPropertyValues opposite owningInstance
}

/*
 * Statement represents an expression of information in an ontology.  
 */
@Bikeshed(heading="Elements")
abstract class Statement extends Element {
}

/*
 * Axiom is an annotated element that represents a statement about a term in a vocabulary.
 */
@Bikeshed(heading="Axioms")
abstract class Axiom extends Element {
}

/*
 * Assertion is an element that represents a statement about an instance in a description.
 */
@Bikeshed(heading="Assertions")
abstract class Assertion extends Element {
}

/*
 * Predicate is an element that represents an ontology statement to match, when used in a rule's antecedent, 
 * or to infer, when used in a rule's consequent.
 */
@Bikeshed(heading="Rules")
abstract class Predicate extends Element {
    /*
     * The rule that specifies this predicate in its antecedent
     */
    container Rule[?] antecedentRule opposite antecedent
    /*
     * The rule that specifies this predicate in its consequent
     */
    container Rule[?] consequentRule opposite consequent
}

/*
 * Literal is an element that represents a specific literal value classified by a scalar.
 */
@Bikeshed(heading="Literals")
abstract class Literal extends Element {
}

////////////////////////////////////////
//  Identified Elements 
////////////////////////////////////////

/*
 * Ontology is an identified element that represents a namespace for its members. The namespace is defined
 * by a globally unique namespace (an iri and a namespace separator that can be # or /) and can be abbreviated with a prefix. 
 * An ontology can import other ontologies, and can make statements about its own as well as imported members.
 */
@Bikeshed(heading="Elements")
abstract class Ontology extends IdentifiedElement {
    /*
     * The globally unique namespace of this ontology
     */
    Namespace[1] namespace
    /*
     * The prefix of this ontology's namespace
     */
    ID[1] prefix
    /*
     * The set of imports this ontology has to other ontologies
     */
    contains Import[*] ownedImports opposite owningOntology
    /*
     * Get the namespace's iri
     */
    op String getIri() {
    	if (namespace === null) {
    		return null
    	}
     	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
        	return namespace
       	} else {
       		return namespace.substring(0, i)
       	}
    }
    /*
     * Get the namespace's separator char
     */
    op SeparatorKind getSeparator() {
     	if (namespace === null) {
    		return null
    	}
    	var i = namespace.indexOf('#')
    	if (i === -1) {
    		i = namespace.lastIndexOf('/')
    	}
    	if (i === -1) {
       		return null
       	} else {
        	return SeparatorKind.get(namespace.substring(i, i+1))
       	}
    }
}

/*
 * Member is an identified element defined by an ontology. Its IRI is unique and derived by concatenating the globally
 * unique namespace of its ontology with its locally unique name (i.e., member.iri=ontology.namespace+member.name).
 */
@Bikeshed(heading="Elements")
abstract class Member extends IdentifiedElement {
    /*
     * The name of this member, which is unique within its ontology's namespace
     */
    id ID[1] name
    
    op String getIri() {
        val ontology = getOntology()
        val namespace = if (ontology !== null) ontology.getNamespace()
        return namespace+name
    }
    /*
     * Gets the abbreviated IRI of this element
     */
    op String getAbbreviatedIri() {
        val ontology = getOntology();
        val prefix = if (ontology !== null) ontology.getPrefix()+':' else ""
        return prefix + name
    }
}

////////////////////////////////////////
//  Ontologies 
////////////////////////////////////////

/*
 * VocabularyBox is an ontology whose members are terms and rules.
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyBox extends Ontology {
}

/*
 * DescriptionBox is an ontology whose members are instances (of terms defined in vocabulary boxes)
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionBox extends Ontology {
}

////////////////////////////////////////
//  Vocabulary Boxes 
////////////////////////////////////////

/*
 * Vocabulary is a vocabulary box that allows making statements about its own terms and rules
 * or about others that are imported.
 */
@Bikeshed(heading="Vocabularies")
class Vocabulary extends VocabularyBox {
    /*
     * The set of statements contained by this vocabulary
     */
    contains VocabularyStatement[*] ownedStatements opposite owningVocabulary
}

/*
 * VocabularyBundle is a vocabulary box that allows importing other vocabulary boxes and flagging them
 * as disjoint from one another.
 */
@Bikeshed(heading="Vocabularies")
class VocabularyBundle extends VocabularyBox {
}

////////////////////////////////////////
//  Description Boxes 
////////////////////////////////////////

/*
 * Description is a description box that allows making statements about its own instances or about
 * others that are imported.
 */
@Bikeshed(heading="Descriptions")
class Description extends DescriptionBox {
    /*
     * The set of statements contained by this description
     */
    contains DescriptionStatement[*] ownedStatements opposite owningDescription
}

/*
 * DescriptionBundle is a description box that allows importing other description boxes and flagging them
 * as a set that is analyzed together for consistency and satisfiabilty.
 */
@Bikeshed(heading="Descriptions")
class DescriptionBundle extends DescriptionBox {
}

////////////////////////////////////////
// Imports 
////////////////////////////////////////

/*
 * Extension is an import that allows an ontology to extend another of the same kind. 
 */
@Bikeshed(heading="Elements")
class Extension extends Import {
}

/*
 * Usage is an import that allows a vocabulary to use a description, a description to use a vocabulary, or
 * a description bundl to use either a vocabulary or a vocabulary bundle.
 */
@Bikeshed(heading="Elements")
class Usage extends Import {
}

/*
 * Inclusion is an import that allows a vocabulary bundle to include a vocabulary, or
 * a description bundle to include a description. 
 */
@Bikeshed(heading="Elements")
class Inclusion extends Import {
}

////////////////////////////////////////
//  Statements 
////////////////////////////////////////

/*
 * VocabularyStatement is a statement owned by a vocabulary.
 */
@Bikeshed(heading="Vocabularies")
abstract class VocabularyStatement extends Statement {
    /*
     * The vocabulary that owns this statement
     */
    container Vocabulary[1] owningVocabulary opposite ownedStatements
}

/*
 * DescriptionStatement is a statement owned by a description.
 */
@Bikeshed(heading="Descriptions")
abstract class DescriptionStatement extends Statement {
    /*
     * The description that owns this statement
     */
    container Description[1] owningDescription opposite ownedStatements
}

////////////////////////////////////////
//  Mmbers 
////////////////////////////////////////

abstract class VocabularyMember extends Member {
}

abstract class DescriptionMember extends Member {
}

////////////////////////////////////////
//  Vocabulary Members
////////////////////////////////////////

/*
 * Term is a member of a vocabulary that provides a particular semantic meaning when used in an assertion.
 */
@Bikeshed(heading="Vocabularies")
abstract class Term extends VocabularyMember {
}

/*
 * Rule is a member of a vocabulary that adds a new inference rule to the set supported natively by DL. A rule specifies a set
 * of antecedent predicates that forms a conjunction that infers, when it holds, a single consequent (relation) predicate. Each
 * predicate in a rule may specify (one or two) variables. Those with the same name refer to the same variable, and hence must
 * be bound to the same value from the model for the rule to trigger during reasoning.
 */
@Bikeshed(heading="Rules")
class Rule extends VocabularyMember, VocabularyStatement {
    /*
     * The set of predicates that form the antecedent of this rule
     */
    contains Predicate[+] antecedent opposite antecedentRule
    /*
     * The relation predicate that is the consequent of this rule
     */
    contains Predicate[+] consequent opposite consequentRule
}

////////////////////////////////////////
//  Terms 
////////////////////////////////////////

/*
 * SpecializableTerm is a term that can specialized in a taxonomy. It can have zero or more specializations.
 */
@Bikeshed(heading="Vocabularies")
abstract class SpecializableTerm extends Term , VocabularyStatement {
    /*
     * The specialization axioms owned by this term
     */
    contains SpecializationAxiom[*] ownedSpecializations opposite owningTerm
}

/*
 * Feature is a a term that can be restricted in a given classifier context
 */
@Bikeshed(heading="Features")
abstract class Feature extends Term {
}

/*
 * Property is a specializable feature that relates an element to a value. It is the super type of all property types.
 */
@Bikeshed(heading="Features")
abstract class Property extends Feature {
}

////////////////////////////////////////
//  Specializable Terms
////////////////////////////////////////

/*
 * Type is a specializable term that classifies a set of instances or literals.
 */
@Bikeshed(heading="Types")
abstract class Type extends SpecializableTerm {
}

////////////////////////////////////////
//  Types
////////////////////////////////////////

/*
 * Classifier is a type that classifies a set of instances and characterizes them with properties
 * (i.e., becomes a domain of these properties). It also inherits properties in the domain of its specialized 
 * types. In addition, it can specify constraints on (direct or inherited) properties in its domain.
 */
@Bikeshed(heading="Types")
abstract class Classifier extends Type {
    /*
     * The set of restriction axioms on properties of this classifier
     */
    contains PropertyRestrictionAxiom[*] ownedPropertyRestrictions opposite owningClassifier
}

/*
 * Scalar is a primitive type that represents a set of literals. It is the super type of all scalar types.
 */
@Bikeshed(heading="Types")
abstract class Scalar extends Type {
}

////////////////////////////////////////
//  Classifiers
////////////////////////////////////////

/*
 * Entity is a characterizable type whose instances can be interrelated by relations (that have the entity
 * or one of its specialized entities as their domain). It can also specify constraints on relations in its domain.
 */
@Bikeshed(heading="Types")
abstract class Entity extends Classifier {
    /*
     * The set of restriction axioms on relations in this entity's domain
     */
    contains RelationRestrictionAxiom[*] ownedRelationRestrictions opposite owningEntity
    /*
     * The unique keys of this entity
     */
    contains KeyAxiom[*] ownedKeys opposite owningEntity
}

/*
 * Structure is a characterizable type that represents a structured datatype whose instances are anonymous and assignable as
 * values to structured properties.
 */
@Bikeshed(heading="Types")
class Structure extends Classifier {
}

////////////////////////////////////////
//  Entities
////////////////////////////////////////

/*
 * Aspect is an entity that represents a concern that cuts across multiple entities. It does not directly 
 * classify instances, but it does so indirectly by being specialized by other entities. However, an aspect can only 
 * specialize other aspects.
 */
@Bikeshed(heading="Types")
class Aspect extends Entity {
}

/*
 * Concept is a concrete entity that classifies a (possibly enumerated) set of concept instances. 
 * It can also specialize other concepts and/or aspects.
 */
@Bikeshed(heading="Types")
class Concept extends Entity {
	/*
	 * The set of enumerated instances of this concept
	 */
	refers ConceptInstance[*] enumeratedInstances
}

/*
 * RelationEntity is a concrete entity that can classify a set of relation instances in a description. It can also specialize 
 * other relation entities and/or aspects. A relation entity relates two entities, a source and a target by a forward relation
 * (from the source to the target). The forward relation can optionally be named, otherwise the default name '[relationEnity]Forward'
 * is assumed. An optional reverse relation (from the target to the source) can also be named.A relation entity can also be characterized 
 * with several boolean flags, representing DL semantics, that apply to the forward relation, and conversely to the reverse relation (if any). 
 */
@Bikeshed(heading="Types")
class RelationEntity extends Entity {
    /*
     * The entity that represents the source of this relation entity
     */
    refers Entity[1] source
    /*
     * The entity that represents the target of this relation entity
     */
    refers Entity[1] target
    /*
     * The optional forward relation of this relation entity
     */
    contains ForwardRelation[?] forwardRelation opposite relationEntity
    /*
     * The optional reverse relation of this relation entity
     */
    contains ReverseRelation[?] reverseRelation opposite relationEntity
    /*
     * Whether this relation entity is functional (i.e., {@code A -> B and A->C => B=C})
     */
    boolean functional
    /*
     * Whether this relation entity is inverse functional (i.e., {@code B->A and C->A => B=C})
     */
    boolean inverseFunctional
    /*
     * Whether this relation entity is symmetric (i.e., {@code A->B => B->A})
     */
    boolean symmetric
    /*
     * Whether this relation entity is asymmetric (i.e., {@code A->B => !(B->A)})
     */
    boolean asymmetric
    /*
     * Whether this relation entity is reflexive (i.e., {@code A => A->A})
     */
    boolean reflexive
    /*
     * Whether this relation entity is irreflexive (i.e., {@code A => !(A->A)})
     */
    boolean irreflexive
    /*
     * Whether this relation entity is irreflexive (i.e., {@code A->B and B->C => A->C})
     */
    boolean transitive
}

////////////////////////////////////////
//  Scalars
////////////////////////////////////////

/*
 * FacetedScalar is a scalar that represents a (possibly infinite) set of literals and can constrain them with some facets. It
 * can also specialize other faceted scalars. OML considers some faceted scalars, those defined by the OWL2 specification 
 * (https://www.w3.org/TR/owl2-syntax/#Datatype_Maps) and listed below, as standard. Other non-standard scalars can specialize directly 
 * or transitively from this standard set and optionally specify facets (restrictions on their lexical or value spaces). 
 * A scalar that specifies facets can only have a single supertype, which must be a standard one. Otherwise, it must have at least one
 * supertype that is considered to be an alias.
 * 
 * Numeric scalars (facets: minInclusive, maxInclusive, minExclusive, maxExclusive):
 * owl:real
 * owl:rational
 * xsd:decimal
 * xsd:integer
 * xsd:nonNegativeInteger
 * xsd:nonPositiveInteger
 * xsd:positiveInteger
 * xsd:negativeInteger
 * xsd:long
 * xsd:int
 * xsd:short
 * xsd:byte
 * xsd:unsignedLong
 * xsd:unsignedInt
 * xsd:unsignedShort
 * xsd:unsignedByte
 * xsd:double
 * xsd:float 
 * 
 * Time scalars (facets: minInclusive, maxInclusive, minExclusive, maxExclusive):
 * xsd:dateTime
 * xsd:dateTimeStamp
 * 
 * Plain scalars (facets: length, minLength, maxLength, pattern, language):
 * rdf:PlainLiteral

 * String scalars (facets: length, minLength, maxLength, pattern)
 * xsd:string,
 * xsd:normalizedString,
 * xsd:token,
 * xsd:language,
 * xsd:Name,
 * xsd:NCName,
 * xsd:NMTOKEN
 * xsd:anyURI
 * 
 * Boolean scalars (no facets):
 * xsd:boolean
 * 
 * Binary scalars (facets: length, minLength, maxLength):
 * xsd:hexBinary
 * xsd:base64Binary
 * 
 * XML scalars (no facets):
 * rdf:XMLLiteral
 */
@Bikeshed(heading="Types")
class FacetedScalar extends Scalar {
    /*
     * The exact length of the literals of this scalar
     */
    UnsignedInteger[?] length
    /*
     * The minimum length of the literals of this scalar
     */
    UnsignedInteger[?] minLength
    /*
     * The maximum length of the literals of this scalar
     */
    UnsignedInteger[?] maxLength
    /*
     * The pattern that the literals of this scalar conforms to
     */
    String[?] pattern
    /*
     * The language range that the literals of this scalar belong to 
     * (based on http://www.rfc-editor.org/rfc/bcp/bcp47.txt)
     */
    String[?] language
    /*
     * The minimum inclusive value of numeric literals of this scalar
     */
    contains Literal[?] minInclusive
    /*
     * The minimum exclusive value of numeric literals of this scalar
     */
    contains Literal[?] minExclusive
    /*
     * The maximum inclusive value of numeric literals of this scalar
     */
    contains Literal[?] maxInclusive
    /*
     * The maximum exclusive value of numeric literals of this scalar
     */
    contains Literal[?] maxExclusive
}

/*
 * EnumeratedScalar is a scalar that represents a finite set of literals. It can specialize another enumerated scalar, but in
 * this case, it cannot define its own literals; rather, it will simply be considered an alias to the specialized scalar.
 */
@Bikeshed(heading="Types")
class EnumeratedScalar extends Scalar {
    /*
     * The set of enumerated literals that are represented by this scalar
     */
    contains Literal[*] literals
}

////////////////////////////////////////
//  Properties
////////////////////////////////////////

/*
 * AnnotationProperty is a property with no DL semantics that relates an annotated element to a literal value.
 */
@Bikeshed(heading="Features")
class AnnotationProperty extends Property, SpecializableTerm {
}

/*
 * SemanticProperty is a property with DL semantics that relates instances of a classifier acting as its
 * domain to a value typed by either a scalar or a structure representing its range.
 */
@Bikeshed(heading="Features")
abstract class SemanticProperty extends Property {
    /*
     * Determines if this property is functional (has a max of one value per instance) 
     */
    op boolean isFunctional()
    /*
     * Gets the domain of this property
     */
    op Classifier getDomain()
    /*
     * Gets the range of the property
     */
    op Type getRange()
}

////////////////////////////////////////
//  Semantic Properties
////////////////////////////////////////

/*
 * ScalarProperty is a semantic property whose range is a scalar. It can specialize other scalar properties.
 * It can also be flagged as a key property (among possibly several) that specifies the unique id of its domain.
 */
@Bikeshed(heading="Features")
class ScalarProperty extends SemanticProperty, SpecializableTerm {
    /*
     * Whether this property is functional (has a max of one value per instance) 
     */
    boolean functional
    /*
     * The classifier that is the domain of this property
     */
    refers Classifier[1] domain
    /*
     * The scalar that is the range of this property
     */
    refers Scalar[1] range
}

/*
 * StructuredProperty is a semantic property whose range is a structure. It can specialize other structured properties.
 */
@Bikeshed(heading="Features")
class StructuredProperty extends SemanticProperty, SpecializableTerm {
    /*
     * Whether this property is functional (has a max of one value per instance) 
     */
    boolean functional
    /*
     * The classifier that is the domain of this property
     */
    refers Classifier[1] domain
    /*
     * The structure that is the range of this property
     */
    refers Structure[1] range
}

/*
 * Relation is a feature that represents a relation from its domain entity to its range entity. It is the super type of
 * two concrete relations: [=ForwardRelation=] and [=ReverseRelation] that are specified by a relation entity. When a relation
 * entity specifies both kinds of relations, they become inverse of each other.
 */
@Bikeshed(heading="Features")
abstract class Relation extends Feature {
    /*
     * The entity that represents the domain of this relation
     */
    refers Entity[1] domain get {
        deriveDomain()
    }
    /*
     * The entity that represents the range of this relation
     */
    refers Entity[1] range get {
        deriveRange()
    }
    /*
     * The relation (if any) that is the inverse of this relation
     */
    refers Relation[?] inverse get {
        deriveInverse()
    }
    /* 
     * Gets the relation entity of this relation 
     */
    op RelationEntity getRelationEntity()
    
    op Entity deriveDomain()
    op Entity deriveRange()
    op Relation deriveInverse()
}

////////////////////////////////////////
//  Relation Properties
////////////////////////////////////////

/*
 * ForwardRelation is a relation that is defined along side a relation entity, whose domain is the source of the relation
 * entity, and whose range is the target of the relation entity. A forward relation has DL semantics that are specified 
 * by the boolean flags of its relation entity.
 */
@Bikeshed(heading="Features")
class ForwardRelation extends Relation {
    /*
     * The relation entity that owns this relation as forward
     */
    container RelationEntity[1] relationEntity opposite forwardRelation
    
    op Entity deriveDomain() {
        if (relationEntity !== null)
            relationEntity.source
    }
    op Entity deriveRange() {
        if (relationEntity !== null)
            relationEntity.target
    }
    op Relation deriveInverse() {
        if (relationEntity !== null)
            relationEntity.reverseRelation
    }
}

/*
 * ReverseRelation is a relation that is defined along side a relation entity, whose domain is the target of 
 * the relation entity, and whose range is the source of the relation entity. A reverse relation has DL semantics that 
 * are the inverse of its entity's forward relation.
 */
@Bikeshed(heading="Features")
class ReverseRelation extends Relation {
    /*
     * The relation entity that owns this reverse relation
     */
    container RelationEntity[1] relationEntity opposite reverseRelation
    
    op Entity deriveDomain() {
        if (relationEntity !== null)
            relationEntity.target
    }
    op Entity deriveRange() {
        if (relationEntity !== null)
            relationEntity.source
    }
    op Relation deriveInverse() {
        if (relationEntity !== null)
            relationEntity.forwardRelation
    }
}

////////////////////////////////////////
//  Description Members
////////////////////////////////////////

/*
 * NamedInstance is an instance that is a member of a description. It can specify links to other named instances.
 */
@Bikeshed(heading="Instances")
abstract class NamedInstance extends Member, Instance, DescriptionStatement {
    /*
     * The links specified by this named instance to other named instances
     */
    contains LinkAssertion[*] ownedLinks opposite owningInstance
}

////////////////////////////////////////
//  Named Instances
////////////////////////////////////////

/*
 * ConceptInstance is a named instance that can be typed by concepts.
 */
@Bikeshed(heading="Instances")
class ConceptInstance extends NamedInstance {
    /*
     * The types of this instance
     */
    contains ConceptTypeAssertion[*] ownedTypes opposite owningInstance
}

/*
 * RelationInstance is a named instance that can be typed by relation entities and that goes from one or more 
 * named instances as sources to one or more named instances as target.
 */
@Bikeshed(heading="Instances")
class RelationInstance extends NamedInstance {
    /*
     * The types of this instance
     */
    contains RelationTypeAssertion[*] ownedTypes opposite owningInstance
    /*
     * The named instances that are the sources of this relation instance
     */
    refers NamedInstance[+] sources
    /*
     * The named instances that are the targets of this relation instance
     */
    refers NamedInstance[+] targets
}

////////////////////////////////////////
//  Instances
////////////////////////////////////////

/*
 * StructureInstance is an instance that can be typed by a structure. It is anonymous and gets assigned as
 * a value for structured properties, either as part of value restrictions on entities, or value assertions on instances.
 */
@Bikeshed(heading="Instances")
class StructureInstance extends Instance {
    /*
     * The type of this instance
     */
    refers Structure[1] ^type
    /*
     * The property value restriction axiom that assigns this instance as a restricted value
     */
    container StructuredPropertyValueRestrictionAxiom[?] owningAxiom opposite value
    /*
     * The property value assertion axiom that assigns this instance as a value
     */
    container StructuredPropertyValueAssertion[?] owningAssertion opposite value
}

////////////////////////////////////////
//  Axioms
////////////////////////////////////////

/*
 * KeyAxiom is an axiom that states that a set of features form a unique key for an entity. This means that all 
 * instances of that entity must have unique values for those keys.
 */
@Bikeshed(heading="Axioms")
class KeyAxiom extends Axiom {
    /*
     * The set of features specified by this axiom as a key
     */
    refers Feature[+] properties
    /*
     * The entity that owns this axiom
     */
    container Entity[?] owningEntity opposite ownedKeys
    /*
     * The reference to an entity that owns this axiom
     */
    container EntityReference[?] owningReference opposite ownedKeys
}

/*
 * SpecializationAxiom is an axiom that states that one specializable term specializes another. It can be specified directly on
 * a specializing term or indirectly on a reference to one.
 */
@Bikeshed(heading="Axioms")
class SpecializationAxiom extends Axiom {
    /*
     * The specialized term specified by this axiom 
     */
    refers SpecializableTerm[1] specializedTerm
    /*
     * The specializing term specified by this axiom 
     */
    container SpecializableTerm[?] owningTerm opposite ownedSpecializations
    /*
     * The reference to a specializing term specified by this axiom 
     */
    container SpecializableTermReference[?] owningReference opposite ownedSpecializations
}

/*
 * RestrictionAxiom is an axiom that states that a term restricts another term.
 */
@Bikeshed(heading="Axioms")
abstract class RestrictionAxiom extends Axiom {
}

////////////////////////////////////////
//  Restriction Axioms
////////////////////////////////////////

/*
 * PropertyRestrictionAxiom is an axiom that places some restriction on the value of a property in the context of
 * the restricting classifier domain. It can be specified directly on the classifier or indirectly on a reference to it.
 */
@Bikeshed(heading="Axioms")
abstract class PropertyRestrictionAxiom extends RestrictionAxiom {
    /*
     * The restricting classifier specified by this axiom
     */
    container Classifier[?] owningClassifier opposite ownedPropertyRestrictions
    /*
     * The reference to a restricting classifier specified by this axiom
     */
    container ClassifierReference[?] owningReference opposite ownedPropertyRestrictions
}

/*
 * ScalarPropertyRestrictionAxiom is a property restriction axiom that is specified on a scalar property.
 */
@Bikeshed(heading="Axioms")
abstract class ScalarPropertyRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * The restricted scalar property specified by this axiom
     */
    refers ScalarProperty[1] property
}

/*
 * ScalarPropertyRangeRestrictionAxiom is a scalar property restriction axiom that restricts the range of a property to
 * a scalar that specializes the original range. This restrictions may apply to all or to some values of the property
 * that have the restricting classifier as a domain.
 */
@Bikeshed(heading="Axioms")
class ScalarPropertyRangeRestrictionAxiom extends ScalarPropertyRestrictionAxiom {
    /*
     * The restricted range specified by this axiom
     */
    refers Scalar[1] range
    /*
     * The range restriction kind specified by this axiom (default is all)
     */
    RangeRestrictionKind[1] kind
}

/*
 * ScalarPropertyCardinalityRestrictionAxiom is a scalar property restriction axiom that restricts the cardinality of a scalar
 * property to an exact number, a minimum number or a maximum number. This restrictions can apply to all values of the property 
 * that have the restricting classifier as a domain, or to those values classified by a specific range subtype.
 */
@Bikeshed(heading="Axioms")
class ScalarPropertyCardinalityRestrictionAxiom extends ScalarPropertyRestrictionAxiom {
    /*
     * The value of the cardinality specified by this axiom (default is 1)
     */
    UnsignedInt[1] cardinality = "1"
    /*
     * The kind of cardinality restriction specified by this axiom (default is exactly)
     */
    CardinalityRestrictionKind[1] kind
    /*
     * The restricted range specified by this axiom
     */
    refers Scalar[?] range
}

/*
 * ScalarPropertyValueRestrictionAxiom is a scalar property restriction axiom that restricts the value of the property 
 * that has the restricting classifier as a domain to a specific literal.
 */
@Bikeshed(heading="Axioms")
class ScalarPropertyValueRestrictionAxiom extends ScalarPropertyRestrictionAxiom {
    /*
     * The literal specified as a restricted property value by this axiom 
     */
    contains Literal[1] value
}

/*
 * StructuredPropertyRestrictionAxiom is a property restriction axiom that is specified on a structured property.
 */
@Bikeshed(heading="Axioms")
abstract class StructuredPropertyRestrictionAxiom extends PropertyRestrictionAxiom {
    /*
     * The restricted structured property specified by this axiom
     */
    refers StructuredProperty[1] property
}

/*
 * StructuredPropertyRangeRestrictionAxiom is a structured property restriction axiom that restricts the range of a property 
 * to a structure that specializes the original range. This restrictions may apply to all or to some values of the 
 * property that have the restricting classifier as a domain.
 */
@Bikeshed(heading="Axioms")
class StructuredPropertyRangeRestrictionAxiom extends StructuredPropertyRestrictionAxiom {
    /*
     * The restricted range specified by this axiom
     */
    refers Structure[1] range
    /*
     * The range restriction kind specified by this axiom (default is all)
     */
    RangeRestrictionKind[1] kind
}

/*
 * StructuredPropertyCardinalityRestrictionAxiom is a structured property restriction axiom that restricts the cardinality of 
 * a structured property to an exact number, a minimum number or a maximum number. This restrictions can apply to all values 
 * of the property that have the restricting classifier as a domain, or to those values classified by a specific range subtype.
 */
@Bikeshed(heading="Axioms")
class StructuredPropertyCardinalityRestrictionAxiom extends StructuredPropertyRestrictionAxiom {
    /*
     * The value of the cardinality specified by this axiom (default is 1)
     */
    UnsignedInt[1] cardinality = "1"
    /*
     * The kind of cardinality restriction specified by this axiom (default is exactly)
     */
    CardinalityRestrictionKind[1] kind
    /*
     * The restricted range specified by this axiom
     */
    refers Structure[?] range
}

/*
 * StructuredPropertyValueRestrictionAxiom is a structured property restriction axiom that restricts the value of the property
 * that has the restricting classifier as a domain to a specific structure instance.
 */
@Bikeshed(heading="Axioms")
class StructuredPropertyValueRestrictionAxiom extends StructuredPropertyRestrictionAxiom {
    /*
     * The structure instance specified as a restricted property value by this axiom 
     */
    contains StructureInstance[1] value opposite owningAxiom
}

/*
 * RelationRestrictionAxiom is an axiom that places some restriction on the target of a relation in the context of
 * the restricting classifier domain. It can be specified directly on the classifier or indirectly on a reference to it.
 */
@Bikeshed(heading="Axioms")
abstract class RelationRestrictionAxiom extends RestrictionAxiom {
    /*
     * The restricted relation specified by this axiom
     */
    refers Relation[1] relation
    /*
     * The restricting entity specified by this axiom
     */
    container Entity[?] owningEntity opposite ownedRelationRestrictions
    /*
     * The reference to a restricting entity specified by this axiom
     */
    container EntityReference[?] owningReference opposite ownedRelationRestrictions
}

/*
 * RelationRangeRestrictionAxiom is a relation restriction axiom that restricts the range of a relation to specific subtype. 
 * This restrictions may apply to all or to some instances of the relation that have an instance of the restricting entity as 
 * a source.
 */
@Bikeshed(heading="Axioms")
class RelationRangeRestrictionAxiom extends RelationRestrictionAxiom {
    /*
     * The restricted range specified by this axiom
     */
    refers Entity[1] range
    /*
     * The range restriction kind specified by this axiom (default is all)
     */
    RangeRestrictionKind[1] kind
}

/*
 * RelationCardinalityRestrictionAxiom is a relation restriction axiom that restricts the cardinality of a relation's range
 * to an exact number, a minimum number or a maximum number. This restrictions may either apply generally to all targets of 
 * of the relation that have instances of the restricting entity as sources, or to those classified by a specific range subtype.
 */
@Bikeshed(heading="Axioms")
class RelationCardinalityRestrictionAxiom extends RelationRestrictionAxiom {
    /*
     * The value of the cardinality specified by this axiom (default is 1)
     */
    UnsignedInt[1] cardinality = "1"
    /*
     * The kind of cardinality restriction specified by this axiom (default is exactly)
     */
    CardinalityRestrictionKind[1] kind
    /*
     * The restricted range specified by this axiom
     */
    refers Entity[?] range
}

/*
 * RelationTargetRestrictionAxiom is a relation restriction axiom that restricts the target of the relation
 * to a specific named instance.
 */
@Bikeshed(heading="Axioms")
class RelationTargetRestrictionAxiom extends RelationRestrictionAxiom {
    /*
     * The named instance specified as a restricted relation target by this axiom 
     */
    refers NamedInstance[1] target
}

////////////////////////////////////////
//  Assertions
////////////////////////////////////////

/*
 * TypeAssertion is an assertion that specifies a type for an instance 
 */
@Bikeshed(heading="Assertions")
abstract class TypeAssertion extends Assertion {
    /*
     * Gets the type referenced by this assertion
     */
    op Entity getType()
}

/*
 * ConceptTypeAssertion is a type assertion specifying a type for a concept instance. It can be specified directly on an
 * concept instance, or indirectly on a reference to one. 
 */
@Bikeshed(heading="Assertions")
class ConceptTypeAssertion extends TypeAssertion {
    /*
     * The concept specified as the type of the instance
     */
    refers Concept[1] ^type
    /*
     * The instance that this type assertion is about
     */
    container ConceptInstance[?] owningInstance opposite ownedTypes
    /*
     * The reference to a concept instance that this type assertion is about
     */
    container ConceptInstanceReference[?] owningReference opposite ownedTypes
}

/*
 * RelationTypeAssertion is a type assertion specifying a relation entity as a type of a relation instance. It can be specified 
 * directly on a relation instance, or indirectly on a reference to one.
 */
@Bikeshed(heading="Assertions")
class RelationTypeAssertion extends TypeAssertion {
    /*
     * The relation entity that is the type of the relation instance
     */
    refers RelationEntity[1] ^type
    /*
     * The relation instance that this type assertion is about
     */
    container RelationInstance[?] owningInstance opposite ownedTypes
    /*
     * The reference to a relation instance that this type assertion is about
     */
    container RelationInstanceReference[?] owningReference opposite ownedTypes
}

/*
 * PropertyValueAssertion is an assertion that specifies a value for a property on an instance.
 */
@Bikeshed(heading="Assertions")
abstract class PropertyValueAssertion extends Assertion {
    /*
     * The instance that this property value assertion is about
     */
    container Instance[?] owningInstance opposite ownedPropertyValues
    /*
     * The reference to an instance that this property value assertion is about
     */
    container NamedInstanceReference[?] owningReference opposite ownedPropertyValues
    /*
     * Gets the property referenced by this assertion
     */
    op SemanticProperty getProperty()
    /*
     * Gets the value specified by this assertion
     */
    op Element getValue()
}

/*
 * ScalarPropertyValueAssertion is a property value assertion for a scalar property, where the specified value is a literal.
 */
@Bikeshed(heading="Assertions")
class ScalarPropertyValueAssertion extends PropertyValueAssertion {
    /*
     * The scalar property specified by this assertion
     */
    refers ScalarProperty[1] property
    /*
     * The literal specified by this assertion as a value
     */
    contains Literal[1] value
}

/*
 * StructuredPropertyValueAssertion is a property value assertion for a structured property, where the specified value is a
 * structure instance.
 */
@Bikeshed(heading="Assertions")
class StructuredPropertyValueAssertion extends PropertyValueAssertion {
    /*
     * The structured property specified by this assertion
     */
    refers StructuredProperty[1] property
    /*
     * The structure instance specified by this assertion as a value
     */
    contains StructureInstance[1] value opposite owningAssertion
}

/*
 * LinkAssertion is an assertion that specifies a link from the asserting named instance as a source to another 
 * named instance as a target. Unlike a relation instance, which is typed by a relation entity, a link references
 * a relation that has the type of the source instance as a conforming domain and the type of the target instance 
 * as a conforming range.
 */
@Bikeshed(heading="Assertions")
class LinkAssertion extends Assertion {
    /*
     * The relation referenced by this link
     */
    refers Relation[1] relation
    /*
     * The named instance that is target of this link
     */
    refers NamedInstance[1] target
    /*
     * The named instance that is the source of this link
     */
    container NamedInstance[?] owningInstance opposite ownedLinks
    /*
     * The reference to a named instance that this the source of this link
     */
    container NamedInstanceReference[?] owningReference opposite ownedLinks
}

////////////////////////////////////////
//  Predicates
////////////////////////////////////////

/*
 * UnaryPredicate is a predicate that binds one variable
 */
@Bikeshed(heading="Rules")
abstract class UnaryPredicate extends Predicate {
    /*
     * The variable name specified by the predicate
     */
    ID[1] variable
}

/*
 * BinaryPredicate is a predicate that takes two arguments: the first is a `variable1` to match to some 
 * instance, and the second is either a `variable2` to match to some instance or a specific `instance2`.
 */
@Bikeshed(heading="Rules")
abstract class BinaryPredicate extends Predicate {
    /*
     * The variable1 specified by the predicate
     */
    ID[1] variable1
    /*
     * The optional variable2 specified by the predicate
     */
    ID[?] variable2
    /*
     * The optional instance2 specified by the predicate
     */
    refers NamedInstance[?] instance2
}

////////////////////////////////////////
//  Unary Predicates
////////////////////////////////////////

/*
 * TypePredicate is a unary predicate that binds its variable to an instance with a specific type.
 */
@Bikeshed(heading="Rules")
class TypePredicate extends UnaryPredicate {
    /*
     * The type of the instance
     */
    refers Type[1] ^type
}

/*
 * RelationEntityPredicate is a binary predicate that binds its `entityVariable` to a relation instance,
 * its `variable1` to the source of that relation instance, and either its `variable2` or `instance2` as the target of
 * that relation instance.
 */
@Bikeshed(heading="Rules")
class RelationEntityPredicate extends BinaryPredicate {
    /*
     * The type of the relation instance
     */
    refers RelationEntity[1] entity
    /*
     * The entity variable specified by the predicate
     */
    ID[1] entityVariable
}

////////////////////////////////////////
//  Unary Predicates
////////////////////////////////////////

/*
 * FeaturePredicate is a binary predicate that binds its `variable1` to an instance (subject), and either its 
 `variable2`, `instance2`, or `literal2` as the value (object) of a specific feature (predicate). 
 */
@Bikeshed(heading="Rules")
class FeaturePredicate extends BinaryPredicate {
    /*
     * The feature of the named instance whose value is bound or matched
     */
    refers Feature[1] feature
    /*
     * The optional literal2 that is matched as a value of the feature
     */
    contains Literal[?] literal2
}

/*
 * SameAsPredicate is a binary predicate that checks that its two arguments bind to the same instance
 */
@Bikeshed(heading="Rules")
class SameAsPredicate extends BinaryPredicate {
}

/*
 * DifferentFromPredicate is a binary predicate that checks that its two arguments bind to different instances
 */
@Bikeshed(heading="Rules")
class DifferentFromPredicate extends BinaryPredicate {
}

////////////////////////////////////////
//  Literals
////////////////////////////////////////

/*
 * QuotedLiteral is a literal that specifies its lexical value as a quoted string along with a language tag, a scalar type, or neither.
 */
@Bikeshed(heading="Literals")
class QuotedLiteral extends Literal  {
    /*
     * The value of this literal represented as a string
     */
    String[1] value
    /*
     * The langTag of this literal
     */
    String[?] langTag
    /*
     * The scalar that is the type of this literal
     */
    refers Scalar[?] ^type
}

/*
 * IntegerLiteral is a literal that represents a 32-bit integer value
 */
@Bikeshed(heading="Literals")
class IntegerLiteral extends Literal  {
    /*
     * The int value of this literal
     */
    int value
}

/*
 * DecimalLiteral is a literal that represents an arbitrary precision decimal value
 */
@Bikeshed(heading="Literals")
class DecimalLiteral extends Literal  {
    /*
     * The decimal value of this literal
     */
    Decimal[1] value
}

/*
 * DoubleLiteral is a literal that represents a 64-bit double precision floating point value
 */
@Bikeshed(heading="Literals")
class DoubleLiteral extends Literal  {
    double value
}

/*
 * BooleanLiteral is a literal that represents the boolean values true/false
 */
@Bikeshed(heading="Literals")
class BooleanLiteral extends Literal {
    /*
     * The boolean value of this literal
     */
    boolean value
}

////////////////////////////////////////
//  References
////////////////////////////////////////

/*
 * Reference is an element that references a member of an ontology, in order to add other annotations to it.
 */
@Bikeshed(heading="References")
abstract class Reference extends Element {
    /*
     * A set of annotations added to the referenced member by this reference
     */
    contains Annotation[*] ownedAnnotations opposite owningReference
}

/*
 * SpecializableTermReference is a reference to a specializable term that can be used to add other 
 * specializations to it.
 */
@Bikeshed(heading="References")
abstract class SpecializableTermReference extends Reference , VocabularyStatement {
    /*
     * The set of specialization axioms added to the referenced term by this reference
     */
    contains SpecializationAxiom[*] ownedSpecializations opposite owningReference
}

/*
 * ClassifierReference is a reference to a classifier that can be used to add other property restrictions to it.
 */
@Bikeshed(heading="References")
abstract class ClassifierReference extends SpecializableTermReference {
    /*
     * The set of property restriction axioms added to the referenced classifier by this reference
     */
    contains PropertyRestrictionAxiom[*] ownedPropertyRestrictions opposite owningReference
}

/*
 * EntityReference is a reference to an entity that can be used to add other relation restrictions to it.
 */
@Bikeshed(heading="References")
abstract class EntityReference extends ClassifierReference {
    /*
     * The set of relation restriction axioms added to the referenced entity by this reference
     */
    contains RelationRestrictionAxiom[*] ownedRelationRestrictions opposite owningReference
    /*
     * The keys of the referenced entity specified by this reference
     */
    contains KeyAxiom[*] ownedKeys opposite owningReference
}

/*
 * AspectReference is a reference to an aspect.
 */
@Bikeshed(heading="References")
class AspectReference extends EntityReference {
    /*
     * The aspect referenced by this reference
     */
    refers Aspect[1] aspect
}

/*
 * ConceptReference is a reference to a concept.
 */
@Bikeshed(heading="References")
class ConceptReference extends EntityReference {
    /*
     * The concept referenced by this reference
     */
    refers Concept[1] concept
}

/*
 * RelationEntityReference is a reference to a relation entity.
 */
@Bikeshed(heading="References")
class RelationEntityReference extends EntityReference {
    /*
     * The relation entity referenced by this reference
     */
    refers RelationEntity[1] entity
}

/*
 * StructureReference is a reference to a structure.
 */
@Bikeshed(heading="References")
class StructureReference extends ClassifierReference {
    /*
     * The structure referenced by this reference
     */
    refers Structure[1] structure
}

/*
 * AnnotationPropertyReference is a reference to an annotation property.
 */
@Bikeshed(heading="References")
class AnnotationPropertyReference extends SpecializableTermReference {
    /*
     * The annotation property referenced by this reference
     */
    refers AnnotationProperty[1] property
}

/*
 * ScalarPropertyReference is a reference to an scalar property.
 */
@Bikeshed(heading="References")
class ScalarPropertyReference extends SpecializableTermReference {
    /*
     * The scalar property referenced by this reference
     */
    refers ScalarProperty[1] property
}

/*
 * StructuredPropertyReference is a reference to an structured property.
 */
@Bikeshed(heading="References")
class StructuredPropertyReference extends SpecializableTermReference {
    /*
     * The structured property referenced by this reference
     */
    refers StructuredProperty[1] property
}

/*
 * FacetedScalarReference is a reference to a faceted scalar.
 */
@Bikeshed(heading="References")
class FacetedScalarReference extends SpecializableTermReference {
    /*
     * The faceted scalar referenced by this reference
     */
    refers FacetedScalar[1] scalar
}

/*
 * EnumeratedScalarReference is a reference to an enumerated scalar.
 */
@Bikeshed(heading="References")
class EnumeratedScalarReference extends SpecializableTermReference {
    /*
     * The enumerated scalar referenced by this reference
     */
    refers EnumeratedScalar[1] scalar
}

/*
 * RelationReference is a reference to an relation.
 */
@Bikeshed(heading="References")
class RelationReference extends Reference , VocabularyStatement {
    /*
     * The relation referenced by this reference
     */
    refers Relation[1] relation
}

/*
 * RuleReference is a reference to a rule.
 */
@Bikeshed(heading="References")
class RuleReference extends Reference , VocabularyStatement {
    /*
     * The rule referenced by this reference
     */
    refers Rule[1] rule
}

/*
 * NamedInstanceReference is a reference to an named instance that can be used to add other property value and
 * links to it.
 */
@Bikeshed(heading="References")
abstract class NamedInstanceReference extends Reference , DescriptionStatement {
    /*
     * The property value assertions added to referenced named instance by this reference
     */
    contains PropertyValueAssertion[*] ownedPropertyValues opposite owningReference
    /*
     * The link assertions added to the referenced named instance by this reference
     */
    contains LinkAssertion[*] ownedLinks opposite owningReference
}

/*
 * ConceptInstanceReference is a reference to a concept instance that can be used to add other types to it 
 */
@Bikeshed(heading="References")
class ConceptInstanceReference extends NamedInstanceReference {
    /*
     * The referenced concept instance
     */
    refers ConceptInstance[1] instance
    /*
     * The set of types added to the referenced concept instance
     */
    contains ConceptTypeAssertion[*] ownedTypes opposite owningReference
}

/*
 * RelationInstanceReference is a reference to a relation instance that can be used to add other types to it.
 */
@Bikeshed(heading="References")
class RelationInstanceReference extends NamedInstanceReference {
    /*
     * The referenced relation instance
     */
    refers RelationInstance[1] instance
    /*
     * The set of type assertions added to the referenced relation instance
     */
    contains RelationTypeAssertion[*] ownedTypes opposite owningReference
}

////////////////////////////////////////
//  Enumerations
////////////////////////////////////////

/*
 * SeparatorKind is an enumeration that specifies the separator character of an ontology's namespace. It can either
 * be only of two values: a hash '#' or a slash '/'.
 */
@Bikeshed(heading="Elements")
enum SeparatorKind {
    hash as '#' = 0
    slash as '/' = 1
}

/*
 * RangeRestrictionKind is an enumeration that specifies the scope of a range restriction on a property or a relation
 */
@Bikeshed(heading="Axioms")
enum RangeRestrictionKind {
    /*
     * All values are restricted to the range
     */
    all = 0
    /*
     * Some values are restricted to the range
     */
    some = 1
}

/*
 * CardinalityRestrictionKind is an enumeration that specifies the kind of cardinality restriction on a property or relation
 */
@Bikeshed(heading="Axioms")
enum CardinalityRestrictionKind {
    /*
     * The cardinality must match this
     */
    exactly = 0
    /*
     * The cardinality is at least this
     */
    min = 1
    /*
     * The cardinality is at most this
     */
    max = 2
}

////////////////////////////////////////
//  Primitive Types
////////////////////////////////////////

@ExtendedMetaData(minInclusive="0", maxInclusive="4294967295")
type UnsignedInt wraps long

@ExtendedMetaData(minInclusive="0", maxInclusive="4294967295")
type UnsignedInteger wraps Long

@ExtendedMetaData(baseType="http://www.w3.org/2001/XMLSchema#decimal")
type Decimal wraps BigDecimal

@ExtendedMetaData(pattern="[a-zA-Z0-9_]([a-zA-Z0-9_\\-.$])*")
type ID wraps String

@ExtendedMetaData(pattern="([^\\s#])*(#|/)", minLength="2")
type Namespace wraps String